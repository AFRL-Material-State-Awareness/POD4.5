<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Complex Step Derivatives</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for complexstep {pracma}"><tr><td>complexstep {pracma}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Complex Step Derivatives</h2>

<h3>Description</h3>

<p>Complex step derivatives of real-valued functions, including gradients,
Jacobians, and Hessians.
</p>


<h3>Usage</h3>

<pre>
complexstep(f, x0, h = 1e-20, ...)

grad_csd(f, x0, h = 1e-20, ...)
jacobian_csd(f, x0, h = 1e-20, ...)
hessian_csd(f, x0, h = 1e-20, ...)
laplacian_csd(f, x0, h = 1e-20, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>f</code></td>
<td>
<p>Function that is to be differentiated.</p>
</td></tr>
<tr valign="top"><td><code>x0</code></td>
<td>
<p>Point at which to differentiate the function.</p>
</td></tr>
<tr valign="top"><td><code>h</code></td>
<td>
<p>Step size to be applied; shall be <em>very</em> small.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Additional variables to be passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Complex step derivation is a fast and highly exact way of numerically
differentiating a function. If the following conditions are satisfied,
there will be no loss of accuracy between computing a function value
and computing the derivative at a certain point.
</p>

<ul>
<li> <p><code>f</code> must have an analytical (i.e., complex differentiable)
continuation into an open neighborhood of <code>x0</code>.
</p>
</li>
<li> <p><code>x0</code> <b>and</b> <code>f(x0)</code> must be real.
</p>
</li>
<li> <p><code>h</code> is real and <em>very</em> small: <code>0 &lt; h &lt;&lt; 1</code>.
</p>
</li></ul>

<p><code>complexstep</code> handles differentiation of univariate functions, while
<code>grad_csd</code> and <code>jacobian_csd</code> compute gradients and Jacobians by
applying the complex step approach iteratively. Please understand that these 
functions are not vectorized, but <code>complexstep</code> is.
</p>
<p>As complex step cannot be applied twice (the first derivative does not
fullfil the conditions), <code>hessian_csd</code> works differently. For the
first derivation, complex step is used, to the one time derived function
Richardson's method is applied. The same applies to <code>lapalacian_csd</code>.
</p>


<h3>Value</h3>

<p><code>complexstep(f, x0)</code> returns the derivative <i>f'(x_0)</i> of <i>f</i>
at <i>x_0</i>. The function is vectorized in <code>x0</code>.  
</p>


<h3>Note</h3>

<p>This surprising approach can be easily deduced from the complex-analytic
Taylor formula.
</p>


<h3>Author(s)</h3>

<p>HwB &lt;hwborchers@googlemail.com&gt;
</p>


<h3>References</h3>

<p>Martins, J. R. R. A., P. Sturdza, and J. J. Alonso (2003).
The Complex-step Derivative Approximation.
ACM Transactions on Mathematical Software, Vol. 29, No. 3, pp. 245&ndash;262.
</p>


<h3>See Also</h3>

<p><code><a href="numderiv.html">numderiv</a></code>
</p>


<h3>Examples</h3>

<pre>
##  Example from Martins et al.
f &lt;- function(x) exp(x)/sqrt(sin(x)^3 + cos(x)^3)  # derivative at x0 = 1.5
# central diff formula    # 4.05342789402801, error 1e-10
# numDeriv::grad(f, 1.5)  # 4.05342789388197, error 1e-12  Richardson
# pracma::numderiv        # 4.05342789389868, error 5e-14  Richardson
complexstep(f, 1.5)       # 4.05342789389862, error 1e-15
# Symbolic calculation:   # 4.05342789389862

jacobian_csd(f, 1.5)

f1 &lt;- function(x) sum(sin(x))
grad_csd(f1, rep(2*pi, 3))
## [1] 1 1 1

laplacian_csd(f1, rep(pi/2, 3))
## [1] -3

f2 &lt;- function(x) c(sin(x[1]) * exp(-x[2]))
hessian_csd(f2, c(0.1, 0.5, 0.9))
##             [,1]        [,2] [,3]
## [1,] -0.06055203 -0.60350053    0
## [2,] -0.60350053  0.06055203    0
## [3,]  0.00000000  0.00000000    0

f3 &lt;- function(u) {
    x &lt;- u[1]; y &lt;- u[2]; z &lt;- u[3]
    matrix(c(exp(x^+y^2), sin(x+y), sin(x)*cos(y), x^2 - y^2), 2, 2)
  }
jacobian_csd(f3, c(1,1,1))
##            [,1]       [,2] [,3]
## [1,]  2.7182818  0.0000000    0
## [2,] -0.4161468 -0.4161468    0
## [3,]  0.2919266 -0.7080734    0
## [4,]  2.0000000 -2.0000000    0
</pre>

<hr /><div style="text-align: center;">[Package <em>pracma</em> version 2.3.8 <a href="00Index.html">Index</a>]</div>
</body></html>
