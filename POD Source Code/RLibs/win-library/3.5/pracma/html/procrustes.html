<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Solving the Procrustes Problem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for procrustes {pracma}"><tr><td>procrustes {pracma}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Solving the Procrustes Problem
</h2>

<h3>Description</h3>

<p><code>procrustes</code> solves for two matrices <code>A</code> and <code>B</code> the 
&lsquo;Procrustes Problem&rsquo; of finding an orthogonal matrix <code>Q</code> such that
<code>A-B*Q</code> has the minimal Frobenius norm.
</p>
<p><code>kabsch</code> determines a best rotation of a given vector set into a
second vector set by minimizing the weighted sum of squared deviations.
The order of vectors is assumed fixed.
</p>


<h3>Usage</h3>

<pre>
procrustes(A, B)

kabsch(A, B, w = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>A, B</code></td>
<td>
<p>two numeric matrices of the same size.</p>
</td></tr>
<tr valign="top"><td><code>w</code></td>
<td>
<p>weights , influence the distance of points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>procrustes(A,B)</code> uses the <code>svd</code> decomposition 
to find an orthogonal matrix <code>Q</code> such that <code>A-B*Q</code> has a 
minimal Frobenius norm, where this norm for a matrix <code>C</code> is defined
as <code>sqrt(Trace(t(C)*C))</code>, or <code>norm(C,'F')</code> in R.
</p>
<p>Solving it with <code>B=I</code> means finding a nearest orthogonal matrix.
</p>
<p><code>kabsch</code> solves a similar problem and uses the Procrustes procedure
for its purpose. Given two sets of points, represented as columns of the
matrices <code>A</code> and <code>B</code>, it determines an orthogonal matrix
<code>U</code> and a translation vector <code>R</code> such that <code>U*A+R-B</code> 
is minimal.
</p>


<h3>Value</h3>

<p><code>procrustes</code> returns a list with components <code>P</code>, which is 
<code>B*Q</code>, then <code>Q</code>, the orthogonal matrix, and <code>d</code>, the
Frobenius norm of <code>A-B*Q</code>.
</p>
<p><code>kabsch</code> returns a list with <code>U</code> the orthogonal matrix applied, 
<code>R</code> the translation vector, and <code>d</code> the least root mean square
between <code>U*A+R</code> and <code>B</code>.
</p>


<h3>Note</h3>

<p>The <code>kabsch</code> function does not take into account scaling of the sets,
but this could easily be integrated.
</p>


<h3>References</h3>

<p>Golub, G. H., and Ch. F. van Loan (1996). Matrix Computations. 3rd Edition,
The John Hopkins University Press, Baltimore London. [Sect. 12.4, p. 601]
</p>
<p>Kabsch, W. (1976). A solution for the best rotation to relate two sets 
of vectors. Acta Cryst A, Vol. 32, p. 9223.
</p>


<h3>See Also</h3>

<p><code><a href="../../base/html/svd.html">svd</a></code>
</p>


<h3>Examples</h3>

<pre>
##  Procrustes
U &lt;- randortho(5)               # random orthogonal matrix
P &lt;- procrustes(U, eye(5))

##  Kabsch
P &lt;- matrix(c(0, 1, 0, 0, 1, 1, 0, 1,
              0, 0, 1, 0, 1, 0, 1, 1,
              0, 0, 0, 1, 0, 1, 1, 1), nrow = 3, ncol = 8, byrow = TRUE)
R &lt;- c(1, 1, 1)
phi &lt;- pi/4
U &lt;- matrix(c(1, 0, 0,
              0, cos(phi), -sin(phi),
              0, sin(phi),  cos(phi)), nrow = 3, ncol = 3, byrow = TRUE)

Q &lt;- U %*% P + R
K &lt;- kabsch(P, Q)
# K$R == R  and  K$U %*% P + c(K$R) == Q
</pre>

<hr /><div style="text-align: center;">[Package <em>pracma</em> version 2.3.8 <a href="00Index.html">Index</a>]</div>
</body></html>
