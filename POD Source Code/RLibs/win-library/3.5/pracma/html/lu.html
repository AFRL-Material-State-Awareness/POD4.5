<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: LU Matrix Factorization</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for lu {pracma}"><tr><td>lu {pracma}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
LU Matrix Factorization
</h2>

<h3>Description</h3>

<p>LU decomposition of a positive definite matrix as Gaussian factorization.
</p>


<h3>Usage</h3>

<pre>
lu(A, scheme = c("kji", "jki", "ijk"))
lu_crout(A)

lufact(A)
lusys(A, b)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>A</code></td>
<td>
<p>square positive definite numeric matrix (will not be checked).</p>
</td></tr>
<tr valign="top"><td><code>scheme</code></td>
<td>
<p>order of row and column operations.</p>
</td></tr>
<tr valign="top"><td><code>b</code></td>
<td>
<p>right hand side of a linear system of equations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given matrix <code>A</code>, the LU decomposition exists and is unique iff
its principal submatrices of order <code>i=1,...,n-1</code> are nonsingular. The
procedure here is a simple Gauss elimination with or without pivoting.
</p>
<p>The scheme abbreviations refer to the order in which the cycles of row- and
column-oriented operations are processed. The &ldquo;ijk&rdquo; scheme is one of the
two compact forms, here the Doolite factorization (the Crout factorization
would be similar).
</p>
<p><code>lu_crout</code> implements the Crout algorithm. For the Doolite algorithm,
the <code>L</code> matrix has ones on its diagonal, for the Crout algorithm, the 
diagonal of the <code>U</code> matrix only has ones.
</p>
<p><code>lufact</code> applies partial pivoting (along the rows).
<code>lusys</code> uses LU factorization to solve the linear system <code>A*x=b</code>.
</p>
<p>These function are not meant to process huge matrices or linear systems of
equations.
Without pivoting they may also be harmed by considerable inaccuracies.
</p>


<h3>Value</h3>

<p><code>lu</code> and <code>lu_crout</code> return a list with components <code>L</code>
and <code>U</code>, the lower and upper triangular matrices such that
<code>A=L%*%U</code>. 
</p>
<p><code>lufact</code> returns a list with <code>L</code> and <code>U</code> combined into one
matrix <code>LU</code>, the <code>rows</code> used in partial pivoting, and <code>det</code>
representing the determinant of <code>A</code>. See the examples how to extract
matrices <code>L</code> and <code>U</code> from <code>LU</code>.
</p>
<p><code>lusys</code> returns the solution of the system as a column vector.
</p>


<h3>Note</h3>

<p>To get the Crout decomposition of a matrix <code>A</code> do
<code>Z &lt;- lu(t(A)); L &lt;- t(Z$U); U &lt;- t(Z$L)</code>.
</p>


<h3>References</h3>

<p>Quarteroni, A., R. Sacco, and F. Saleri (2007). Numerical Mathematics.
Second edition, Springer-Verlag, Berlin Heidelberg.
</p>
<p>J.H. Mathews and K.D. Fink (2003). Numerical Methods Using MATLAB.
Fourth Edition, Pearson (Prentice-Hall), updated 2006.
</p>


<h3>See Also</h3>

<p><code><a href="../../Matrix/html/qr-methods.html">qr</a></code>
</p>


<h3>Examples</h3>

<pre>
A &lt;- magic(5)
D &lt;- lu(A, scheme = "ijk")     # Doolittle scheme
D$L %*% D$U
##      [,1] [,2] [,3] [,4] [,5]
## [1,]   17   24    1    8   15
## [2,]   23    5    7   14   16
## [3,]    4    6   13   20   22
## [4,]   10   12   19   21    3
## [5,]   11   18   25    2    9

H4 &lt;- hilb(4)
lufact(H4)$det
## [1] 0.0000001653439

x0 &lt;- c(1.0, 4/3, 5/3, 2.0)
b  &lt;- H4 %*% x0
lusys(H4, b)
##          [,1]
## [1,] 1.000000
## [2,] 1.333333
## [3,] 1.666667
## [4,] 2.000000
</pre>

<hr /><div style="text-align: center;">[Package <em>pracma</em> version 2.3.8 <a href="00Index.html">Index</a>]</div>
</body></html>
