<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Linear Projection onto a Subspace</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for linearproj, affineproj {pracma}"><tr><td>linearproj, affineproj {pracma}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Linear Projection onto a Subspace
</h2>

<h3>Description</h3>

<p>Computes the projection of points in the columns of B onto the
linear subspace spaned by the columns of A, resp. the projection
of a point onto an affine subspace and its distance.
</p>


<h3>Usage</h3>

<pre>
  linearproj(A, B)

  affineproj(x0, C, b, unbound = TRUE, maxniter = 100)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>A</code></td>
<td>
<p>Matrix whose columns span a subspace of some R^n.</p>
</td></tr>
<tr valign="top"><td><code>B</code></td>
<td>
<p>Matrix whose columns are to be projected.</p>
</td></tr>
<tr valign="top"><td><code>x0</code></td>
<td>
<p>Point in R^n to be projected onto C x = b.</p>
</td></tr>
<tr valign="top"><td><code>C, b</code></td>
<td>
<p>Matrix and vector, defining an affine subspace as C x = b</p>
</td></tr>
<tr valign="top"><td><code>unbound</code></td>
<td>
<p>Logical; require all x &gt;= 0 if unbound is false.</p>
</td></tr>
<tr valign="top"><td><code>maxniter</code></td>
<td>
<p>Maximum number of iterations (if  is unbound is false).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>linearproj</code> projects points onto a <em>linear</em> subspace in R^n.
The columns of A are assumed be the basis of a linear subspace, esp.
they are required to be linearly independent. The columns of matrix B
define points in R^n that will be projected onto A, and their resp.
coefficients in terms of the basis in A are computed.
</p>
<p>The columns of A need to be linearly independent; if not, generate an 
orthonormal basis of this subspace with <code>orth(A)</code>. If you want to 
project points onto a subspace that is defined by <code>A x = 0</code>, then 
generate an orthonormal basis of the nullspace of A with <code>null(A)</code>.
</p>
<p>Technically, the orthogonal projection can be determined by a finite 
'Fourier expansion' with coefficients calculated as scalar products,
see the examples.
</p>
<p><code>affineproj</code> projects (single) points onto an affine subspace 
defined by <code>A x = b</code> and calculates the distance of <code>x0</code> from 
this subspace. The calculation is based on the following formula:
</p>
<p style="text-align: center;"><i>p = (I - A' (A A')^{-1}) x0 + A' (A A')^{-1} b</i></p>

<p>Technically, if <code>a</code> is one solution of <code>C x = b</code>, then the 
projection onto C can be derived from the projection onto S = C x = 0
with <code>proj_C(x) = a + proj_S(x - a)</code>, see the examples.
</p>
<p>In case the user requests the coordinates of the projected point to be 
positive, an iteration procedure is started where negative coordinates 
are set to zero in each iteration.
</p>


<h3>Value</h3>

<p>The functions <code>linearproj</code> returns a list with components P and Q. 
The columns of P contain the coefficients &ndash; in the basis of A &ndash; of the 
corresponding projected points in B, and the columns of Q are the the 
coordinates of these points in the natural coordinate system of R^n.
</p>
<p><code>affineproj</code> returns a list with components <code>proj</code>, <code>dist</code>, 
and <code>niter</code>. <code>proj</code> is the projected point, <code>dist</code> the 
distance from the subspace (and <code>niter</code> the number of iterations 
if positivity of the coordinates was requested.).
</p>


<h3>Note</h3>

<p>Some timings show that these implementations are to a certain extent
competitive with direct applications of quadprog.
</p>


<h3>Author(s)</h3>

<p>Hans W. Borchers, partly based on code snippets by Ravi Varadhan.
</p>


<h3>References</h3>

<p>G. Strang (2006). Linear Algebra and Its Applications. Fourth Edition,
Cengage Learning, Boston, MA.
</p>


<h3>See Also</h3>

<p><code><a href="nullspace.html">nullspace</a></code>, <code><a href="orth.html">orth</a></code>
</p>


<h3>Examples</h3>

<pre>
#-- Linear projection --------------------------------------------------

# Projection onto the line (1,1,1) in R^3
A &lt;- matrix(c(1,1,1), 3, 1)
B &lt;- matrix(c(1,0,0, 1,2,3, -1,0,1), 3, 3)
S &lt;- linearproj(A, B)
## S$Q
##           [,1] [,2] [,3]
## [1,] 0.3333333    2    0
## [2,] 0.3333333    2    0
## [3,] 0.3333333    2    0

# Fourier expansion': sum(&lt;x0, a_i&gt; a_i /&lt;a_i, a_i&gt;), a_i = A[ ,i]
dot(c(1,2,3), A) * A / dot(A, A)    # A has only one column

#-- Affine projection --------------------------------------------------

# Projection onto the (hyper-)surface x+y+z = 1 in R^3
A &lt;- t(A); b &lt;- 1
x0 &lt;- c(1,2,3)
affineproj(x0, A, b)            # (-2/3, 1/3, 4/3)

# Linear translation: Let S be the linear subspace and A the parallel
# affine subspace of A x = b, a the solution of the linear system, then
#   proj_A(x) = a + proj_S(x-a)
a &lt;- qr.solve(A, b)
A0 &lt;- nullspace(A)
xp &lt;- c(a + linearproj(A0, x0 - a)$Q)
## [1] -0.6666667  0.3333333  1.3333333

#-- Projection with positivity ----------------------- 24 ms -- 1.3 s --
s &lt;- affineproj(x0, A, b, unbound = FALSE)
zapsmall(s$proj)                 # [1] 0 0 1
## $x     : 0.000000e+00 3.833092e-17 1.000000e+00
## $niter : 35

#-- Extended Example ------------------------------------------ 80 ms --
## Not run: 
set.seed(65537)
n = 1000; m = 100                       # dimension, codimension
x0 &lt;- rep(0, n)                         # project (0, ..., 0)
A &lt;- matrix(runif(m*n), nrow = m)       # 100 x 1000
b &lt;- rep(1, m)                          # A x = b, linear system
a &lt;- qr.solve(A, b)                     # A a = b, LS solution
A0 &lt;- nullspace(A)                      # 1000 x 900, base of &lt;A&gt;
xp &lt;- a+drop(A0 %*% dot(x0-a, A0))      # projection
Norm(xp - x0)                           # [1] 0.06597077

## End(Not run)

#-- Solution with quadprog ------------------------------------ 40 ms --
# D &lt;- diag(1, n)             # quadratic form
# A1 &lt;- rbind(A, diag(1, n))  # A x = b and
# b1 &lt;- c(b, rep(0, n))       #   x &gt;= 0
# n &lt;- nrow(A)
# sol = quadprog::solve.QP(D, x0, t(A1), b1, meq = n)
# xp &lt;- sol$solution

#-- Solution with CVXR ---------------------------------------- 50 ms --
# library(CVXR)
# x = Variable(n)                             # n decision variables
# objective = Minimize(p_norm(x0 - x))        # min! || p0 - x ||
# constraint = list(A %*% x == b, x &gt;= 0)     # A x = b, x &gt;= 0
# problem = Problem(objective, constraint)
# solution = solve(problem)                   # Solver: ECOS
# solution$value                              # 
# xp &lt;- solution$getValue(x)                  # 
</pre>

<hr /><div style="text-align: center;">[Package <em>pracma</em> version 2.3.8 <a href="00Index.html">Index</a>]</div>
</body></html>
