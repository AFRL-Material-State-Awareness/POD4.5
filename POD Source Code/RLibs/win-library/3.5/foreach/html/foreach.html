<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: foreach</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for foreach {foreach}"><tr><td>foreach {foreach}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>foreach</h2>

<h3>Description</h3>

<p><code style="white-space: pre;">%do%</code> and <code style="white-space: pre;">%dopar%</code> are binary operators that operate
on a <code>foreach</code> object and an <code>R</code> expression.
The expression, <code>ex</code>, is evaluated multiple times in an environment
that is created by the <code>foreach</code> object, and that environment is
modified for each evaluation as specified by the <code>foreach</code> object.
<code style="white-space: pre;">%do%</code> evaluates the expression sequentially, while <code style="white-space: pre;">%dopar%</code>
evaluates it in parallel.
The results of evaluating <code>ex</code> are returned as a list by default,
but this can be modified by means of the <code>.combine</code> argument.
</p>


<h3>Usage</h3>

<pre>
foreach(
  ...,
  .combine,
  .init,
  .final = NULL,
  .inorder = TRUE,
  .multicombine = FALSE,
  .maxcombine = if (.multicombine) 100 else 2,
  .errorhandling = c("stop", "remove", "pass"),
  .packages = NULL,
  .export = NULL,
  .noexport = NULL,
  .verbose = FALSE
)

e1 %:% e2

when(cond)

obj %do% ex

obj %dopar% ex

times(n)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>...</code></td>
<td>
<p>one or more arguments that control how <code>ex</code> is
evaluated.  Named arguments specify the name and values of variables
to be defined in the evaluation environment.
An unnamed argument can be used to specify the number of times that
<code>ex</code> should be evaluated.
At least one argument must be specified in order to define the
number of times <code>ex</code> should be executed.
</p>
<p>If multiple arguments are supplied, the number of times <code>ex</code> is
evaluated is equal to the smallest number of iterations among the supplied
arguments. See the examples.</p>
</td></tr>
<tr valign="top"><td><code>.combine</code></td>
<td>
<p>function that is used to process the tasks results as
they generated.  This can be specified as either a function or
a non-empty character string naming the function.
Specifying 'c' is useful for concatenating the results into
a vector, for example.  The values 'cbind' and 'rbind' can combine
vectors into a matrix.  The values '+' and '*' can be used to
process numeric data.
By default, the results are returned in a list.</p>
</td></tr>
<tr valign="top"><td><code>.init</code></td>
<td>
<p>initial value to pass as the first argument of the
<code>.combine</code> function.
This should not be specified unless <code>.combine</code> is also specified.</p>
</td></tr>
<tr valign="top"><td><code>.final</code></td>
<td>
<p>function of one argument that is called to return final result.</p>
</td></tr>
<tr valign="top"><td><code>.inorder</code></td>
<td>
<p>logical flag indicating whether the <code>.combine</code>
function requires the task results to be combined in the same order
that they were submitted.  If the order is not important, then it
setting <code>.inorder</code> to <code>FALSE</code> can give improved performance.
The default value is 'TRUE.</p>
</td></tr>
<tr valign="top"><td><code>.multicombine</code></td>
<td>
<p>logical flag indicating whether the <code>.combine</code>
function can accept more than two arguments.
If an arbitrary <code>.combine</code> function is specified, by default,
that function will always be called with two arguments.
If it can take more than two arguments, then setting <code>.multicombine</code>
to <code>TRUE</code> could improve the performance.
The default value is <code>FALSE</code> unless the <code>.combine</code>
function is <code>cbind</code>, <code>rbind</code>, or <code>c</code>, which are known
to take more than two arguments.</p>
</td></tr>
<tr valign="top"><td><code>.maxcombine</code></td>
<td>
<p>maximum number of arguments to pass to the combine function.
This is only relevant if <code>.multicombine</code> is <code>TRUE</code>.</p>
</td></tr>
<tr valign="top"><td><code>.errorhandling</code></td>
<td>
<p>specifies how a task evaluation error should be handled.
If the value is &quot;stop&quot;, then execution will be stopped via
the <code>stop</code> function if an error occurs.
If the value is &quot;remove&quot;, the result for that task will not be
returned, or passed to the <code>.combine</code> function.
If it is &quot;pass&quot;, then the error object generated by task evaluation
will be included with the rest of the results.  It is assumed that
the combine function (if specified) will be able to deal with the
error object.
The default value is &quot;stop&quot;.</p>
</td></tr>
<tr valign="top"><td><code>.packages</code></td>
<td>
<p>character vector of packages that the tasks depend on.
If <code>ex</code> requires a <code>R</code> package to be loaded, this option
can be used to load that package on each of the workers.
Ignored when used with <code style="white-space: pre;">%do%</code>.</p>
</td></tr>
<tr valign="top"><td><code>.export</code></td>
<td>
<p>character vector of variables to export.
This can be useful when accessing a variable that isn't defined in the
current environment.
The default value in <code>NULL</code>.</p>
</td></tr>
<tr valign="top"><td><code>.noexport</code></td>
<td>
<p>character vector of variables to exclude from exporting.
This can be useful to prevent variables from being exported that aren't
actually needed, perhaps because the symbol is used in a model formula.
The default value in <code>NULL</code>.</p>
</td></tr>
<tr valign="top"><td><code>.verbose</code></td>
<td>
<p>logical flag enabling verbose messages.  This can be
very useful for trouble shooting.</p>
</td></tr>
<tr valign="top"><td><code>e1</code></td>
<td>
<p><code>foreach</code> object to merge.</p>
</td></tr>
<tr valign="top"><td><code>e2</code></td>
<td>
<p><code>foreach</code> object to merge.</p>
</td></tr>
<tr valign="top"><td><code>cond</code></td>
<td>
<p>condition to evaluate.</p>
</td></tr>
<tr valign="top"><td><code>obj</code></td>
<td>
<p><code>foreach</code> object used to control the evaluation
of <code>ex</code>.</p>
</td></tr>
<tr valign="top"><td><code>ex</code></td>
<td>
<p>the <code>R</code> expression to evaluate.</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>number of times to evaluate the <code>R</code> expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>foreach</code> and <code style="white-space: pre;">%do%</code>/<code style="white-space: pre;">%dopar%</code> operators provide
a looping construct that can be viewed as a hybrid of the standard
<code>for</code> loop and <code>lapply</code> function.
It looks similar to the <code>for</code> loop, and it evaluates an expression,
rather than a function (as in <code>lapply</code>), but its purpose is to
return a value (a list, by default), rather than to cause side-effects.
This facilitates parallelization, but looks more natural to people that
prefer <code>for</code> loops to <code>lapply</code>.
</p>
<p>The <code style="white-space: pre;">%:%</code> operator is the <em>nesting</em> operator, used for creating
nested foreach loops. Type <code>vignette("nested")</code> at the R prompt for
more details.
</p>
<p>Parallel computation depends upon a <em>parallel backend</em> that must be
registered before performing the computation. The parallel backends available
will be system-specific, but include <code>doParallel</code>, which uses R's built-in
<span class="pkg">parallel</span> package. Each parallel backend has a specific registration function,
such as <code>registerDoParallel</code>.
</p>
<p>The <code>times</code> function is a simple convenience function that calls
<code>foreach</code>.  It is useful for evaluating an <code>R</code> expression multiple
times when there are no varying arguments.  This can be convenient for
resampling, for example.
</p>


<h3>See Also</h3>

<p><code><a href="../../iterators/html/iter.html">iterators::iter</a></code>
</p>


<h3>Examples</h3>

<pre>
# equivalent to rnorm(3)
times(3) %do% rnorm(1)

# equivalent to lapply(1:3, sqrt)
foreach(i=1:3) %do%
  sqrt(i)

# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
	sqrt(i+j)

# equivalent to colMeans(m)
m &lt;- matrix(rnorm(9), 3, 3)
foreach(i=1:ncol(m), .combine=c) %do%
  mean(m[,i])

# normalize the rows of a matrix in parallel, with parenthesis used to
# force proper operator precedence
# Need to register a parallel backend before this example will run
# in parallel
foreach(i=1:nrow(m), .combine=rbind) %dopar%
  (m[i,] / mean(m[i,]))

# simple (and inefficient) parallel matrix multiply
library(iterators)
a &lt;- matrix(1:16, 4, 4)
b &lt;- t(a)
foreach(b=iter(b, by='col'), .combine=cbind) %dopar%
  (a %*% b)

# split a data frame by row, and put them back together again without
# changing anything
d &lt;- data.frame(x=1:10, y=rnorm(10))
s &lt;- foreach(d=iter(d, by='row'), .combine=rbind) %dopar% d
identical(s, d)

# a quick sort function
qsort &lt;- function(x) {
  n &lt;- length(x)
  if (n == 0) {
    x
  } else {
    p &lt;- sample(n, 1)
    smaller &lt;- foreach(y=x[-p], .combine=c) %:% when(y &lt;= x[p]) %do% y
    larger  &lt;- foreach(y=x[-p], .combine=c) %:% when(y &gt;  x[p]) %do% y
    c(qsort(smaller), x[p], qsort(larger))
  }
}
qsort(runif(12))

</pre>

<hr /><div style="text-align: center;">[Package <em>foreach</em> version 1.5.2 <a href="00Index.html">Index</a>]</div>
</body></html>
