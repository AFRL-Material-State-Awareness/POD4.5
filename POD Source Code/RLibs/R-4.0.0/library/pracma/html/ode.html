<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Non-stiff (and stiff) ODE solvers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for ode23 {pracma}"><tr><td>ode23 {pracma}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Non-stiff (and stiff) ODE solvers
</h2>

<h3>Description</h3>

<p>Runge-Kutta (2, 3)-method with variable step size, resp. (4,5)-method
with Dormand-Price coefficients, or (7,8)-pairs with Fehlberg coefficients.
The function <code>f(t, y)</code> has to return the derivative as a column vector.
</p>


<h3>Usage</h3>

<pre>
ode23(f, t0, tfinal, y0, ..., rtol = 1e-3, atol = 1e-6)

ode23s(f, t0, tfinal, y0, jac = NULL, ...,
            rtol = 1e-03, atol = 1e-06, hmax = 0.0)

ode45(f, t0, tfinal, y0, ..., atol = 1e-6, hmax = 0.0)
ode78(f, t0, tfinal, y0, ..., atol = 1e-6, hmax = 0.0)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>f</code></td>
<td>
<p>function in the differential equation <i>y' = f(x, y)</i>;<br />
defined as a function <i>R \times R^m \rightarrow R^m</i>, where
<i>m</i> is the number of equations.</p>
</td></tr>
<tr valign="top"><td><code>t0, tfinal</code></td>
<td>
<p>start and end points of the interval.</p>
</td></tr>
<tr valign="top"><td><code>y0</code></td>
<td>
<p>starting values as column vector;
for <i>m</i> equations <code>u0</code> needs to be a vector of length <code>m</code>.</p>
</td></tr>
<tr valign="top"><td><code>jac</code></td>
<td>
<p>jacobian of <code>f</code> as a function of <code>x</code> alone;
if not specified, a finite difference approximation will be used.</p>
</td></tr>
<tr valign="top"><td><code>rtol, atol</code></td>
<td>
<p>relative and absolute tolerance.</p>
</td></tr>
<tr valign="top"><td><code>hmax</code></td>
<td>
<p>maximal step size, default is <code>(tfinal - t0)/10.</code></p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Additional parameters to be passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ode23</code> is an integration method for systems of ordinary differential
equations using second and third order Runge-Kutta-Fehlberg formulas with
automatic step-size.
</p>
<p><code>ode23s</code> can be used to solve a stiff system of ordinary differential
equations, based on a modified Rosenbrock triple method of order (2,3);
See section 4.1 in [Shampine and Reichelt].
</p>
<p><code>ode45</code> implements Dormand-Prince (4,5) pair that minimizes the local
truncation error in the 5th-order estimate which is what is used to step
forward (local extrapolation). Generally it produces more accurate results
and costs roughly the same computationally.
</p>
<p><code>ode78</code> implements Fehlberg's (7,8) pair and is a 7th-order accurate
integrator therefore the local error normally expected is O(h^8).  However,
because this particular implementation uses the 8th-order estimate for xout
(i.e. local extrapolation) moving forward with the 8th-order estimate will
yield errors on the order of O(h^9). It requires 13 function evaluations per
integration step.
</p>


<h3>Value</h3>

<p>List with components <code>t</code> for grid (or &lsquo;time&rsquo;) points between <code>t0</code>
and <code>tfinal</code>, and <code>y</code> an n-by-m matrix with solution variables in
columns, i.e. each row contains one time stamp.
</p>


<h3>Note</h3>

<p>Copyright (c) 2004 C. Moler for the Matlab textbook version <code>ode23tx</code>.
</p>


<h3>References</h3>

<p>Ascher, U. M., and L. R. Petzold (1998). Computer Methods for Ordinary
Differential Equations and Differential-Algebraic Equations. SIAM.
</p>
<p>L.F. Shampine and M.W. Reichelt (1997). The MATLAB ODE Suite.
SIAM Journal on Scientific Computing, Vol. 18, pp. 1-22.
</p>
<p>Moler, C. (2004). Numerical Computing with Matlab. Revised Reprint, SIAM.
<a href="https://www.mathworks.com/moler/chapters.html">https://www.mathworks.com/moler/chapters.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="rk4.html">rk4sys</a></code>, <code><a href="deval.html">deval</a></code>
</p>


<h3>Examples</h3>

<pre>
##  Example1: Three-body problem
f &lt;- function(t, y)
		as.matrix(c(y[2]*y[3], -y[1]*y[3], 0.51*y[1]*y[2]))
y0 &lt;- as.matrix(c(0, 1, 1))
t0 &lt;- 0; tf &lt;- 20
sol &lt;- ode23(f, t0, tf, y0, rtol=1e-5, atol=1e-10)
## Not run: 
matplot(sol$t, sol$y, type = "l", lty = 1, lwd = c(2, 1, 1),
        col = c("darkred", "darkblue", "darkgreen"),
        xlab = "Time [min]", ylab= "",
        main = "Three-body Problem")
grid()
## End(Not run)

##  Example2: Van der Pol Equation
#   x'' + (x^2 - 1) x' + x = 0
f &lt;- function(t, x)
        as.matrix(c(x[1] * (1 - x[2]^2) -x[2], x[1]))
t0 &lt;- 0; tf &lt;- 20
x0 &lt;- as.matrix(c(0, 0.25))
sol &lt;- ode23(f, t0, tf, x0)
## Not run: 
plot(c(0, 20), c(-3, 3), type = "n",
     xlab = "Time", ylab = "", main = "Van der Pol Equation")
lines(sol$t, sol$y[, 1], col = "blue")
lines(sol$t, sol$y[, 2], col = "darkgreen")
grid()
## End(Not run)

##  Example3: Van der Pol as stiff equation
vdP  &lt;- function(t,y) as.matrix(c(y[2], 10*(1-y[1]^2)*y[2]-y[1]))
ajax &lt;- function(t, y)
            matrix(c(0, 1, -20*y[1]*y[2]-1, 10*(1-y[1]^2)), 2,2, byrow = TRUE)
sol &lt;- ode23s(vdP, t0, tf, c(2, 0), jac = ajax, hmax = 1.0)
## Not run: 
plot(sol$t, sol$y[, 1], col = "blue")
lines(sol$t, sol$y[, 1], col = "blue")
lines(sol$t, sol$y[, 2]/8, col = "red", lwd = 2)
grid()
## End(Not run)

##  Example4: pendulum
m = 1.0;  l = 1.0   # [kg] resp. [m]
g = 9.81; b = 0.7   # [m/s^2] resp. [N s/m]
fp = function(t, x)
        c( x[2] , 1/(1/3*m*l^2)*(-b*x[2]-m*g*l/2*sin(x[1])) )
t0 &lt;- 0.0; tf &lt;- 5.0; hmax = 0.1
y0 = c(30*pi/180, 0.0)
sol = ode45(fp, t0, tf, y0, hmax = 0.1)
## Not run: 
matplot(sol$t, sol$y, type = "l", lty = 1)
grid()
## End(Not run)

##  Example: enforced pendulum
g &lt;- 9.81
L &lt;- 1.0; Y &lt;- 0.25; w &lt;- 2.5
f &lt;- function(t, y) {
    as.matrix(c(y[2], -g/L * sin(y[1]) + w^2/L * Y * cos(y[1]) * sin(w*t)))
}
y0 &lt;- as.matrix(c(0, 0))
sol &lt;- ode78(f, 0.0, 60.0, y0, hmax = 0.05)
## Not run: 
plot(sol$t, sol$y[, 1], type="l", col="blue")
grid()
## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>pracma</em> version 2.3.8 <a href="00Index.html">Index</a>]</div>
</body></html>
