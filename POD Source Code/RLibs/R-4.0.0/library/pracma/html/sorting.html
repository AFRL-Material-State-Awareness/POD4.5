<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Sorting Routines</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for sorting {pracma}"><tr><td>sorting {pracma}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Sorting Routines</h2>

<h3>Description</h3>

<p>R implementations of several sorting routines. These implementations are
meant for demonstration and lecturing purposes.
</p>


<h3>Usage</h3>

<pre>
is.sorted(a)
testSort(n = 1000)

bubbleSort(a)
insertionSort(a)
selectionSort(a)
shellSort(a, f = 2.3)
heapSort(a)
mergeSort(a, m = 10)
mergeOrdered(a, b)
quickSort(a, m = 3)
quickSortx(a, m = 25)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>a, b</code></td>
<td>
<p>Numeric vectors to be sorted or merged.</p>
</td></tr>
<tr valign="top"><td><code>f</code></td>
<td>
<p>Retracting factor for <code>shellSort</code>.</p>
</td></tr>
<tr valign="top"><td><code>m</code></td>
<td>
<p>Size of subsets that are sorted by <code>insertionSort</code> when the
sorting procedure is called recursively.</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>Only in <code>testSort</code>: the length of a vector of random numbers
to be sorted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bubbleSort(a)</code> is the well-known &ldquo;bubble sort&rdquo; routine; it is
forbiddingly slow.
</p>
<p><code>insertionSort(a)</code> sorts the array one entry at a time; it is slow,
but quite efficient for small data sets.
</p>
<p><code>selectionSort(a)</code> is an in-place sorting routine that is inefficient,
but noted for its simplicity.
</p>
<p><code>shellSort(a, f = 2.3)</code> exploits the fact that insertion sort works
efficiently on input that is already almost sorted. It reduces the gaps
by the factor <code>f</code>; <code>f=2.3</code> is said to be a reasonable choice.
</p>
<p><code>heapSort(a)</code> is not yet implemented.
</p>
<p><code>mergeSort(a, m = 10)</code> works recursively, merging already sorted parts
with <code>mergeOrdered</code>. <code>m</code> should be between<code>3</code> and 1/1000 of
the size of <code>a</code>.
</p>
<p><code>mergeOrdered(a, b)</code> works only correctly if <code>a</code> and <code>a</code>
are already sorted.
</p>
<p><code>quickSort(a, m = 3)</code> realizes the celebrated &ldquo;quicksort algorithm&rdquo;
and is the fastest of all implementations here. To avoid too deeply nested
recursion with R, <code>insertionSort</code> is called when the size of a subset
is smaller than <code>m</code>.
</p>
<p>Values between <code>3..30</code> seem reasonable and smaller values are better,
with the risk of running into a too deeply nested recursion.
</p>
<p><code>quickSort(a, m = 25)</code> is an extended version where the split is
calculated more carefully, but in general this approach takes too much
time.
</p>
<p>Values for <code>m</code> are <code>20..40</code> with <code>m=25</code> favoured.
</p>
<p><code>testSort(n = 1000)</code> is a test routine, e.g. for testing your
computer power. On an iMac, <code>quickSort</code> will sort an array of
size 1,000,000 in less than 15 secs.
</p>


<h3>Value</h3>

<p>All routines return the vector sorted.
</p>
<p><code>is.sorted</code> indicates logically whether the vector is sorted.
</p>


<h3>Note</h3>

<p>At the moment, only increasingly sorting is possible
(if needed apply <code>rev</code> afterwards).
</p>


<h3>Author(s)</h3>

<p>HwB &lt;hwborchers@googlemail.com&gt;
</p>


<h3>References</h3>

<p>Knuth, D. E. (1973). The Art of Computer Programming, Volume 3: Sorting
and Searching, Chapter 5: Sorting. Addison-Wesley Publishing Company.
</p>


<h3>See Also</h3>

<p><code><a href="../../base/html/sort.html">sort</a></code>, the internal C-based sorting routine.
</p>


<h3>Examples</h3>

<pre>
## Not run: 
testSort(100)

a &lt;- sort(runif(1000)); b &lt;- sort(runif(1000))
system.time(y &lt;- mergeSort(c(a, b)))
system.time(y &lt;- mergeOrdered(a, b))
is.sorted(y)
## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>pracma</em> version 2.3.8 <a href="00Index.html">Index</a>]</div>
</body></html>
