<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Compute M-estimators of regression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for lmrob..M..fit {robustbase}"><tr><td>lmrob..M..fit {robustbase}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Compute M-estimators of regression</h2>

<h3>Description</h3>

<p>This function performs RWLS iterations to find an
M-estimator of regression.  When started from an S-estimated
<code>beta.initial</code>, this results in an MM-estimator.
</p>


<h3>Usage</h3>

<pre>
lmrob..M..fit(x, y, beta.initial, scale, control, obj,
              mf = obj$model, method = obj$control$method)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>design matrix (<i>n x p</i>) typically including a
column of <code>1</code>s for the intercept.</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>numeric response vector (of length <i>n</i>).</p>
</td></tr>
<tr valign="top"><td><code>beta.initial</code></td>
<td>
<p>numeric vector (of length <i>p</i>) of initial
estimate.  Usually the result of an S-regression estimator.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>robust residual scale estimate. Usually
an S-scale estimator.</p>
</td></tr>
<tr valign="top"><td><code>control</code></td>
<td>
<p>list of control parameters, as returned
by <code><a href="lmrob.control.html">lmrob.control</a></code>.  Currently, the components
<code>c("max.it", "rel.tol","trace.lev", "psi", "tuning.psi", "mts", "subsampling")</code>
are accessed.</p>
</td></tr>
<tr valign="top"><td><code>obj</code></td>
<td>
<p>an optional <code>lmrob</code>-object.  If specified, this is
typically used to set values for the other arguments.</p>
</td></tr>
<tr valign="top"><td><code>mf</code></td>
<td>
<p>unused and deprecated.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>optional; the <code>method</code> used for <em>obj</em> computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code><a href="lmrob.fit.html">lmrob.fit</a></code> (and
<code>anova(&lt;lmrob&gt;, type = "Deviance")</code>) and typically not to be used
on its own.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>coef</code></td>
<td>
<p>the M-estimator (or MM-estim.) of regression</p>
</td></tr>
<tr valign="top"><td><code>control</code></td>
<td>
<p>the <code>control</code> list input used</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p> The residual scale estimate</p>
</td></tr>
<tr valign="top"><td><code>seed </code></td>
<td>
<p> The random number generator seed</p>
</td></tr>
<tr valign="top"><td><code>converged</code></td>
<td>
 <p><code>TRUE</code> if the RWLS iterations converged,
<code>FALSE</code> otherwise</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera and Martin Maechler</p>


<h3>References</h3>

<p>Yohai, 1987
</p>


<h3>See Also</h3>

<p><code><a href="lmrob.fit.html">lmrob.fit</a></code>, <code><a href="lmrob.html">lmrob</a></code>;
<code><a href="../../MASS/html/rlm.html">rlm</a></code> from package <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a>.
</p>


<h3>Examples</h3>

<pre>
data(stackloss)
X &lt;- model.matrix(stack.loss ~ . , data = stackloss)
y &lt;- stack.loss
## Compute manual MM-estimate:
## 1) initial LTS:
m0 &lt;- ltsReg(X[,-1], y)
## 2) M-estimate started from LTS:
m1 &lt;- lmrob..M..fit(X, y, beta.initial = coef(m0), scale = m0$scale, method = "SM",
                    control = lmrob.control(tuning.psi = 1.6, psi = 'bisquare'))
## no 'method' (nor 'obj'):
m1. &lt;- lmrob..M..fit(X, y, beta.initial = coef(m0), scale = m0$scale,
                     control = m1$control)
stopifnot(all.equal(m1, m1., tol = 1e-15)) # identical {call *not* stored!}

cbind(m0$coef, m1$coef)
## the scale is kept fixed:
stopifnot(identical(unname(m0$scale), m1$scale))

##  robustness weights: are
r.s &lt;- with(m1, residuals/scale) # scaled residuals
m1.wts &lt;- Mpsi(r.s, cc = 1.6, psi="tukey") / r.s
summarizeRobWeights(m1.wts)
##--&gt; outliers 1,3,4,13,21
which(m0$lts.wt == 0) # 1,3,4,21 but not 13

## Manually add M-step to SMD-estimate (=&gt; equivalent to "SMDM"):
m2 &lt;- lmrob(stack.loss ~ ., data = stackloss, method = 'SMD')
m3 &lt;- lmrob..M..fit(obj = m2)

## Simple function that allows custom initial estimates
## (Deprecated; use init argument to lmrob() instead.) %% MM: why deprecated?
lmrob.custom &lt;- function(x, y, beta.initial, scale, terms) {
  ## initialize object
  obj &lt;- list(control = lmrob.control("KS2011"),
              terms = terms) ## terms is needed for summary()
  ## M-step
  obj &lt;- lmrob..M..fit(x, y, beta.initial, scale, obj = obj)
  ## D-step
  obj &lt;- lmrob..D..fit(obj, x)
  ## Add some missing elements
  obj$cov &lt;- TRUE ## enables calculation of cov matrix
  obj$p &lt;- obj$qr$rank
  obj$degree.freedom &lt;- length(y) - obj$p
  ## M-step
  obj &lt;- lmrob..M..fit(x, y, obj=obj)
  obj$control$method &lt;- ".MDM"
  obj
}

m4 &lt;- lmrob.custom(X, y, m2$init$init.S$coef,
                   m2$init$scale, m2$terms)
stopifnot(all.equal(m4$coef, m3$coef))

## Start from ltsReg:
m5 &lt;- ltsReg(stack.loss ~ ., data = stackloss)
m6 &lt;- lmrob.custom(m5$X, m5$Y, coef(m5), m5$scale, m5$terms)
</pre>

<hr /><div style="text-align: center;">[Package <em>robustbase</em> version 0.95-0 <a href="00Index.html">Index</a>]</div>
</body></html>
