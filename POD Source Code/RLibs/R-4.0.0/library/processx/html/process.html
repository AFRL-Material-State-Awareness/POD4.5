<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: External process</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for process {processx}"><tr><td>process {processx}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>External process</h2>

<h3>Description</h3>

<p>Managing external processes from R is not trivial, and this
class aims to help with this deficiency. It is essentially a small
wrapper around the <code>system</code> base R function, to return the process
id of the started process, and set its standard output and error
streams. The process id is then used to manage the process.
</p>


<h3>Batch files</h3>

<p>Running Windows batch files (<code>.bat</code> or <code>.cmd</code> files) may be complicated
because of the <code>cmd.exe</code> command line parsing rules. For example you
cannot easily have whitespace in both the command (path) and one of the
arguments. To work around these limitations you need to start a
<code>cmd.exe</code> shell explicitly and use its <code>call</code> command. For example:
</p>
<div class="sourceCode r"><pre>process$new("cmd.exe", c("/c", "call", bat_file, "arg 1", "arg 2"))
</pre></div>
<p>This works even if <code>bat_file</code> contains whitespace characters.
For more information about this, see this processx issue:
https://github.com/r-lib/processx/issues/301
</p>
<p>The detailed parsing rules are at
https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmd
</p>
<p>A very good practical guide is at
https://ss64.com/nt/syntax-esc.html
</p>


<h3>Polling</h3>

<p>The <code>poll_io()</code> function polls the standard output and standard
error connections of a process, with a timeout. If there is output
in either of them, or they are closed (e.g. because the process exits)
<code>poll_io()</code> returns immediately.
</p>
<p>In addition to polling a single process, the <code><a href="poll.html">poll()</a></code> function
can poll the output of several processes, and returns as soon as any
of them has generated output (or exited).
</p>


<h3>Cleaning up background processes</h3>

<p>processx kills processes that are not referenced any more (if <code>cleanup</code>
is set to <code>TRUE</code>), or the whole subprocess tree (if <code>cleanup_tree</code> is
also set to <code>TRUE</code>).
</p>
<p>The cleanup happens when the references of the processes object are
garbage collected. To clean up earlier, you can call the <code>kill()</code> or
<code>kill_tree()</code> method of the process(es), from an <code>on.exit()</code> expression,
or an error handler:
</p>
<div class="sourceCode r"><pre>process_manager &lt;- function() {
  on.exit({
    try(p1$kill(), silent = TRUE)
    try(p2$kill(), silent = TRUE)
  }, add = TRUE)
  p1 &lt;- process$new("sleep", "3")
  p2 &lt;- process$new("sleep", "10")
  p1$wait()
  p2$wait()
}
process_manager()
</pre></div>
<p>If you interrupt <code>process_manager()</code> or an error happens then both <code>p1</code>
and <code>p2</code> are cleaned up immediately. Their connections will also be
closed. The same happens at a regular exit.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-process-new"><code>process$new()</code></a>
</p>
</li>
<li> <p><a href="#method-process-finalize"><code>process$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-process-kill"><code>process$kill()</code></a>
</p>
</li>
<li> <p><a href="#method-process-kill_tree"><code>process$kill_tree()</code></a>
</p>
</li>
<li> <p><a href="#method-process-signal"><code>process$signal()</code></a>
</p>
</li>
<li> <p><a href="#method-process-interrupt"><code>process$interrupt()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_pid"><code>process$get_pid()</code></a>
</p>
</li>
<li> <p><a href="#method-process-is_alive"><code>process$is_alive()</code></a>
</p>
</li>
<li> <p><a href="#method-process-wait"><code>process$wait()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_exit_status"><code>process$get_exit_status()</code></a>
</p>
</li>
<li> <p><a href="#method-process-format"><code>process$format()</code></a>
</p>
</li>
<li> <p><a href="#method-process-print"><code>process$print()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_start_time"><code>process$get_start_time()</code></a>
</p>
</li>
<li> <p><a href="#method-process-is_supervised"><code>process$is_supervised()</code></a>
</p>
</li>
<li> <p><a href="#method-process-supervise"><code>process$supervise()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_output"><code>process$read_output()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_error"><code>process$read_error()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_output_lines"><code>process$read_output_lines()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_error_lines"><code>process$read_error_lines()</code></a>
</p>
</li>
<li> <p><a href="#method-process-is_incomplete_output"><code>process$is_incomplete_output()</code></a>
</p>
</li>
<li> <p><a href="#method-process-is_incomplete_error"><code>process$is_incomplete_error()</code></a>
</p>
</li>
<li> <p><a href="#method-process-has_input_connection"><code>process$has_input_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-has_output_connection"><code>process$has_output_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-has_error_connection"><code>process$has_error_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-has_poll_connection"><code>process$has_poll_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_input_connection"><code>process$get_input_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_output_connection"><code>process$get_output_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_error_connection"><code>process$get_error_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_all_output"><code>process$read_all_output()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_all_error"><code>process$read_all_error()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_all_output_lines"><code>process$read_all_output_lines()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_all_error_lines"><code>process$read_all_error_lines()</code></a>
</p>
</li>
<li> <p><a href="#method-process-write_input"><code>process$write_input()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_input_file"><code>process$get_input_file()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_output_file"><code>process$get_output_file()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_error_file"><code>process$get_error_file()</code></a>
</p>
</li>
<li> <p><a href="#method-process-poll_io"><code>process$poll_io()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_poll_connection"><code>process$get_poll_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_result"><code>process$get_result()</code></a>
</p>
</li>
<li> <p><a href="#method-process-as_ps_handle"><code>process$as_ps_handle()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_name"><code>process$get_name()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_exe"><code>process$get_exe()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_cmdline"><code>process$get_cmdline()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_status"><code>process$get_status()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_username"><code>process$get_username()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_wd"><code>process$get_wd()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_cpu_times"><code>process$get_cpu_times()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_memory_info"><code>process$get_memory_info()</code></a>
</p>
</li>
<li> <p><a href="#method-process-suspend"><code>process$suspend()</code></a>
</p>
</li>
<li> <p><a href="#method-process-resume"><code>process$resume()</code></a>
</p>
</li></ul>


<hr>
<a id="method-process-new"></a>



<h4>Method <code>new()</code></h4>

<p>Start a new process in the background, and then return immediately.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$new(
  command = NULL,
  args = character(),
  stdin = NULL,
  stdout = NULL,
  stderr = NULL,
  pty = FALSE,
  pty_options = list(),
  connections = list(),
  poll_connection = NULL,
  env = NULL,
  cleanup = TRUE,
  cleanup_tree = FALSE,
  wd = NULL,
  echo_cmd = FALSE,
  supervise = FALSE,
  windows_verbatim_args = FALSE,
  windows_hide_window = FALSE,
  windows_detached_process = !cleanup,
  encoding = "",
  post_process = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>command</code></dt><dd><p>Character scalar, the command to run.
Note that this argument is not passed to a shell, so no
tilde-expansion or variable substitution is performed on it.
It should not be quoted with <code><a href="../../base/html/shQuote.html">base::shQuote()</a></code>. See
<code><a href="../../base/html/normalizePath.html">base::normalizePath()</a></code> for tilde-expansion. If you want to run
<code>.bat</code> or <code>.cmd</code> files on Windows, make sure you read the
'Batch files' section above.</p>
</dd>
<dt><code>args</code></dt><dd><p>Character vector, arguments to the command. They will be
passed to the process as is, without a shell transforming them,
They don't need to be escaped.</p>
</dd>
<dt><code>stdin</code></dt><dd><p>What to do with the standard input. Possible values:
</p>

<ul>
<li> <p><code>NULL</code>: set to the <em>null device</em>, i.e. no standard input is
provided;
</p>
</li>
<li><p> a file name, use this file as standard input;
</p>
</li>
<li> <p><code>"|"</code>: create a (writeable) connection for stdin.
</p>
</li>
<li> <p><code>""</code> (empty string): inherit it from the main R process. If the
main R process does not have a standard input stream, e.g. in
RGui on Windows, then an error is thrown.
</p>
</li></ul>
</dd>
<dt><code>stdout</code></dt><dd><p>What to do with the standard output. Possible values:
</p>

<ul>
<li> <p><code>NULL</code>: discard it;
</p>
</li>
<li><p> A string, redirect it to this file.
Note that if you specify a relative path, it will be relative to
the current working directory, even if you specify another
directory in the <code>wd</code> argument. (See issue 324.)
</p>
</li>
<li> <p><code>"|"</code>: create a connection for it.
</p>
</li>
<li> <p><code>""</code> (empty string): inherit it from the main R process. If the
main R process does not have a standard output stream, e.g. in
RGui on Windows, then an error is thrown.
</p>
</li></ul>
</dd>
<dt><code>stderr</code></dt><dd><p>What to do with the standard error. Possible values:
</p>

<ul>
<li> <p><code>NULL</code>: discard it.
</p>
</li>
<li><p> A string, redirect it to this file.
Note that if you specify a relative path, it will be relative to
the current working directory, even if you specify another
directory in the <code>wd</code> argument. (See issue 324.)
</p>
</li>
<li> <p><code>"|"</code>: create a connection for it.
</p>
</li>
<li> <p><code>"2&gt;&amp;1"</code>: redirect it to the same connection (i.e. pipe or file)
as <code>stdout</code>. <code>"2&gt;&amp;1"</code> is a way to keep standard output and error
correctly interleaved.
</p>
</li>
<li> <p><code>""</code> (empty string): inherit it from the main R process. If the
main R process does not have a standard error stream, e.g. in
RGui on Windows, then an error is thrown.
</p>
</li></ul>
</dd>
<dt><code>pty</code></dt><dd><p>Whether to create a pseudo terminal (pty) for the
background process. This is currently only supported on Unix
systems, but not supported on Solaris.
If it is <code>TRUE</code>, then the <code>stdin</code>, <code>stdout</code> and <code>stderr</code> arguments
must be <code>NULL</code>. If a pseudo terminal is created, then processx
will create pipes for standard input and standard output. There is
no separate pipe for standard error, because there is no way to
distinguish between stdout and stderr on a pty. Note that the
standard output connection of the pty is <em>blocking</em>, so we always
poll the standard output connection before reading from it using
the <code style="white-space: pre;">$read_output()</code> method. Also, because <code style="white-space: pre;">$read_output_lines()</code>
could still block if no complete line is available, this function
always fails if the process has a pty. Use <code style="white-space: pre;">$read_output()</code> to
read from ptys.</p>
</dd>
<dt><code>pty_options</code></dt><dd><p>Unix pseudo terminal options, a named list. see
<code><a href="default_pty_options.html">default_pty_options()</a></code> for details and defaults.</p>
</dd>
<dt><code>connections</code></dt><dd><p>A list of processx connections to pass to the
child process. This is an experimental feature currently.</p>
</dd>
<dt><code>poll_connection</code></dt><dd><p>Whether to create an extra connection to the
process that allows polling, even if the standard input and
standard output are not pipes. If this is <code>NULL</code> (the default),
then this connection will be only created if standard output and
standard error are not pipes, and <code>connections</code> is an empty list.
If the poll connection is created, you can query it via
<code>p$get_poll_connection()</code> and it is also included in the response
to <code>p$poll_io()</code> and <code><a href="poll.html">poll()</a></code>. The numeric file descriptor of the
poll connection comes right after <code>stderr</code> (2), and the
connections listed in <code>connections</code>.</p>
</dd>
<dt><code>env</code></dt><dd><p>Environment variables of the child process. If <code>NULL</code>,
the parent's environment is inherited. On Windows, many programs
cannot function correctly if some environment variables are not
set, so we always set <code>HOMEDRIVE</code>, <code>HOMEPATH</code>, <code>LOGONSERVER</code>,
<code>PATH</code>, <code>SYSTEMDRIVE</code>, <code>SYSTEMROOT</code>, <code>TEMP</code>, <code>USERDOMAIN</code>,
<code>USERNAME</code>, <code>USERPROFILE</code> and <code>WINDIR</code>. To append new environment
variables to the ones set in the current process, specify
<code>"current"</code> in <code>env</code>, without a name, and the appended ones with
names. The appended ones can overwrite the current ones.</p>
</dd>
<dt><code>cleanup</code></dt><dd><p>Whether to kill the process when the <code>process</code>
object is garbage collected.</p>
</dd>
<dt><code>cleanup_tree</code></dt><dd><p>Whether to kill the process and its child
process tree when the <code>process</code> object is garbage collected.</p>
</dd>
<dt><code>wd</code></dt><dd><p>Working directory of the process. It must exist.
If <code>NULL</code>, then the current working directory is used.</p>
</dd>
<dt><code>echo_cmd</code></dt><dd><p>Whether to print the command to the screen before
running it.</p>
</dd>
<dt><code>supervise</code></dt><dd><p>Whether to register the process with a supervisor.
If <code>TRUE</code>, the supervisor will ensure that the process is
killed when the R process exits.</p>
</dd>
<dt><code>windows_verbatim_args</code></dt><dd><p>Whether to omit quoting the arguments
on Windows. It is ignored on other platforms.</p>
</dd>
<dt><code>windows_hide_window</code></dt><dd><p>Whether to hide the application's window
on Windows. It is ignored on other platforms.</p>
</dd>
<dt><code>windows_detached_process</code></dt><dd><p>Whether to use the
<code>DETACHED_PROCESS</code> flag on Windows. If this is <code>TRUE</code>, then
the child process will have no attached console, even if the
parent had one.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>The encoding to assume for <code>stdin</code>, <code>stdout</code> and
<code>stderr</code>. By default the encoding of the current locale is
used. Note that <code>processx</code> always reencodes the output of the
<code>stdout</code> and <code>stderr</code> streams in UTF-8 currently.
If you want to read them without any conversion, on all platforms,
specify <code>"UTF-8"</code> as encoding.</p>
</dd>
<dt><code>post_process</code></dt><dd><p>An optional function to run when the process has
finished. Currently it only runs if <code style="white-space: pre;">$get_result()</code> is called.
It is only run once.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>R6 object representing the process.
</p>


<hr>
<a id="method-process-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>Cleanup method that is called when the <code>process</code> object is garbage
collected. If requested so in the process constructor, then it
eliminates all processes in the process's subprocess tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$finalize()</pre></div>


<hr>
<a id="method-process-kill"></a>



<h4>Method <code>kill()</code></h4>

<p>Terminate the process. It also terminate all of its child
processes, except if they have created a new process group (on Unix),
or job object (on Windows). It returns <code>TRUE</code> if the process
was terminated, and <code>FALSE</code> if it was not (because it was
already finished/dead when <code>processx</code> tried to terminate it).
</p>


<h5>Usage</h5>

<div class="r"><pre>process$kill(grace = 0.1, close_connections = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grace</code></dt><dd><p>Currently not used.</p>
</dd>
<dt><code>close_connections</code></dt><dd><p>Whether to close standard input, standard
output, standard error connections and the poll connection, after
killing the process.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-kill_tree"></a>



<h4>Method <code>kill_tree()</code></h4>

<p>Process tree cleanup. It terminates the process
(if still alive), together with any child (or grandchild, etc.)
processes. It uses the <em>ps</em> package, so that needs to be installed,
and <em>ps</em> needs to support the current platform as well. Process tree
cleanup works by marking the process with an environment variable,
which is inherited in all child processes. This allows finding
descendents, even if they are orphaned, i.e. they are not connected
to the root of the tree cleanup in the process tree any more.
<code style="white-space: pre;">$kill_tree()</code> returns a named integer vector of the process ids that
were killed, the names are the names of the processes (e.g. <code>"sleep"</code>,
<code>"notepad.exe"</code>, <code>"Rterm.exe"</code>, etc.).
</p>


<h5>Usage</h5>

<div class="r"><pre>process$kill_tree(grace = 0.1, close_connections = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grace</code></dt><dd><p>Currently not used.</p>
</dd>
<dt><code>close_connections</code></dt><dd><p>Whether to close standard input, standard
output, standard error connections and the poll connection, after
killing the process.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-signal"></a>



<h4>Method <code>signal()</code></h4>

<p>Send a signal to the process. On Windows only the
<code>SIGINT</code>, <code>SIGTERM</code> and <code>SIGKILL</code> signals are interpreted,
and the special 0 signal. The first three all kill the process. The 0
signal returns <code>TRUE</code> if the process is alive, and <code>FALSE</code>
otherwise. On Unix all signals are supported that the OS supports,
and the 0 signal as well.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$signal(signal)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>signal</code></dt><dd><p>An integer scalar, the id of the signal to send to
the process. See <code><a href="../../tools/html/pskill.html">tools::pskill()</a></code> for the list of signals.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-interrupt"></a>



<h4>Method <code>interrupt()</code></h4>

<p>Send an interrupt to the process. On Unix this is a
<code>SIGINT</code> signal, and it is usually equivalent to pressing CTRL+C at
the terminal prompt. On Windows, it is a CTRL+BREAK keypress.
Applications may catch these events. By default they will quit.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$interrupt()</pre></div>


<hr>
<a id="method-process-get_pid"></a>



<h4>Method <code>get_pid()</code></h4>

<p>Query the process id.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_pid()</pre></div>



<h5>Returns</h5>

<p>Integer scalar, the process id of the process.
</p>


<hr>
<a id="method-process-is_alive"></a>



<h4>Method <code>is_alive()</code></h4>

<p>Check if the process is alive.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$is_alive()</pre></div>



<h5>Returns</h5>

<p>Logical scalar.
</p>


<hr>
<a id="method-process-wait"></a>



<h4>Method <code>wait()</code></h4>

<p>Wait until the process finishes, or a timeout happens.
Note that if the process never finishes, and the timeout is infinite
(the default), then R will never regain control. In some rare cases,
<code style="white-space: pre;">$wait()</code> might take a bit longer than specified to time out. This
happens on Unix, when another package overwrites the processx
<code>SIGCHLD</code> signal handler, after the processx process has started.
One such package is parallel, if used with fork clusters, e.g.
through <code>parallel::mcparallel()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$wait(timeout = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>timeout</code></dt><dd><p>Timeout in milliseconds, for the wait or the I/O
polling.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>It returns the process itself, invisibly.
</p>


<hr>
<a id="method-process-get_exit_status"></a>



<h4>Method <code>get_exit_status()</code></h4>

<p><code style="white-space: pre;">$get_exit_status</code> returns the exit code of the process if it has
finished and <code>NULL</code> otherwise. On Unix, in some rare cases, the exit
status might be <code>NA</code>. This happens if another package (or R itself)
overwrites the processx <code>SIGCHLD</code> handler, after the processx process
has started. In these cases processx cannot determine the real exit
status of the process. One such package is parallel, if used with
fork clusters, e.g. through the <code>parallel::mcparallel()</code> function.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_exit_status()</pre></div>


<hr>
<a id="method-process-format"></a>



<h4>Method <code>format()</code></h4>

<p><code>format(p)</code> or <code>p$format()</code> creates a string representation of the
process, usually for printing.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$format()</pre></div>


<hr>
<a id="method-process-print"></a>



<h4>Method <code>print()</code></h4>

<p><code>print(p)</code> or <code>p$print()</code> shows some information about the
process on the screen, whether it is running and it's process id, etc.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$print()</pre></div>


<hr>
<a id="method-process-get_start_time"></a>



<h4>Method <code>get_start_time()</code></h4>

<p><code style="white-space: pre;">$get_start_time()</code> returns the time when the process was
started.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_start_time()</pre></div>


<hr>
<a id="method-process-is_supervised"></a>



<h4>Method <code>is_supervised()</code></h4>

<p><code style="white-space: pre;">$is_supervised()</code> returns whether the process is being tracked by
supervisor process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$is_supervised()</pre></div>


<hr>
<a id="method-process-supervise"></a>



<h4>Method <code>supervise()</code></h4>

<p><code style="white-space: pre;">$supervise()</code> if passed <code>TRUE</code>, tells the supervisor to start
tracking the process. If <code>FALSE</code>, tells the supervisor to stop
tracking the process. Note that even if the supervisor is disabled
for a process, if it was started with <code>cleanup = TRUE</code>, the process
will still be killed when the object is garbage collected.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$supervise(status)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>status</code></dt><dd><p>Whether to turn on of off the supervisor for this
process.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-read_output"></a>



<h4>Method <code>read_output()</code></h4>

<p><code style="white-space: pre;">$read_output()</code> reads from the standard output connection of the
process. If the standard output connection was not requested, then
then it returns an error. It uses a non-blocking text connection. This
will work only if <code>stdout="|"</code> was used. Otherwise, it will throw an
error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_output(n = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of characters or lines to read.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-read_error"></a>



<h4>Method <code>read_error()</code></h4>

<p><code style="white-space: pre;">$read_error()</code> is similar to <code style="white-space: pre;">$read_output</code>, but it reads
from the standard error stream.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_error(n = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of characters or lines to read.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-read_output_lines"></a>



<h4>Method <code>read_output_lines()</code></h4>

<p><code style="white-space: pre;">$read_output_lines()</code> reads lines from standard output connection
of the process. If the standard output connection was not requested,
then it returns an error. It uses a non-blocking text connection.
This will work only if <code>stdout="|"</code> was used. Otherwise, it will
throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_output_lines(n = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of characters or lines to read.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-read_error_lines"></a>



<h4>Method <code>read_error_lines()</code></h4>

<p><code style="white-space: pre;">$read_error_lines()</code> is similar to <code style="white-space: pre;">$read_output_lines</code>, but
it reads from the standard error stream.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_error_lines(n = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of characters or lines to read.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-is_incomplete_output"></a>



<h4>Method <code>is_incomplete_output()</code></h4>

<p><code style="white-space: pre;">$is_incomplete_output()</code> return <code>FALSE</code> if the other end of
the standard output connection was closed (most probably because the
process exited). It return <code>TRUE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$is_incomplete_output()</pre></div>


<hr>
<a id="method-process-is_incomplete_error"></a>



<h4>Method <code>is_incomplete_error()</code></h4>

<p><code style="white-space: pre;">$is_incomplete_error()</code> return <code>FALSE</code> if the other end of
the standard error connection was closed (most probably because the
process exited). It return <code>TRUE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$is_incomplete_error()</pre></div>


<hr>
<a id="method-process-has_input_connection"></a>



<h4>Method <code>has_input_connection()</code></h4>

<p><code style="white-space: pre;">$has_input_connection()</code> return <code>TRUE</code> if there is a connection
object for standard input; in other words, if <code>stdout="|"</code>. It returns
<code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$has_input_connection()</pre></div>


<hr>
<a id="method-process-has_output_connection"></a>



<h4>Method <code>has_output_connection()</code></h4>

<p><code style="white-space: pre;">$has_output_connection()</code> returns <code>TRUE</code> if there is a connection
object for standard output; in other words, if <code>stdout="|"</code>. It returns
<code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$has_output_connection()</pre></div>


<hr>
<a id="method-process-has_error_connection"></a>



<h4>Method <code>has_error_connection()</code></h4>

<p><code style="white-space: pre;">$has_error_connection()</code> returns <code>TRUE</code> if there is a connection
object for standard error; in other words, if <code>stderr="|"</code>. It returns
<code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$has_error_connection()</pre></div>


<hr>
<a id="method-process-has_poll_connection"></a>



<h4>Method <code>has_poll_connection()</code></h4>

<p><code style="white-space: pre;">$has_poll_connection()</code> return <code>TRUE</code> if there is a poll connection,
<code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$has_poll_connection()</pre></div>


<hr>
<a id="method-process-get_input_connection"></a>



<h4>Method <code>get_input_connection()</code></h4>

<p><code style="white-space: pre;">$get_input_connection()</code> returns a connection object, to the
standard input stream of the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_input_connection()</pre></div>


<hr>
<a id="method-process-get_output_connection"></a>



<h4>Method <code>get_output_connection()</code></h4>

<p><code style="white-space: pre;">$get_output_connection()</code> returns a connection object, to the
standard output stream of the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_output_connection()</pre></div>


<hr>
<a id="method-process-get_error_connection"></a>



<h4>Method <code>get_error_connection()</code></h4>

<p><code style="white-space: pre;">$get_error_conneciton()</code> returns a connection object, to the
standard error stream of the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_error_connection()</pre></div>


<hr>
<a id="method-process-read_all_output"></a>



<h4>Method <code>read_all_output()</code></h4>

<p><code style="white-space: pre;">$read_all_output()</code> waits for all standard output from the process.
It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentially several <code>readLines()</code> calls.
It returns a character scalar. This will return content only if
<code>stdout="|"</code> was used. Otherwise, it will throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_all_output()</pre></div>


<hr>
<a id="method-process-read_all_error"></a>



<h4>Method <code>read_all_error()</code></h4>

<p><code style="white-space: pre;">$read_all_error()</code> waits for all standard error from the process.
It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentially several <code>readLines()</code> calls.
It returns a character scalar. This will return content only if
<code>stderr="|"</code> was used. Otherwise, it will throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_all_error()</pre></div>


<hr>
<a id="method-process-read_all_output_lines"></a>



<h4>Method <code>read_all_output_lines()</code></h4>

<p><code style="white-space: pre;">$read_all_output_lines()</code> waits for all standard output lines
from a process. It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentially several <code>readLines()</code> calls.
It returns a character vector. This will return content only if
<code>stdout="|"</code> was used. Otherwise, it will throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_all_output_lines()</pre></div>


<hr>
<a id="method-process-read_all_error_lines"></a>



<h4>Method <code>read_all_error_lines()</code></h4>

<p><code style="white-space: pre;">$read_all_error_lines()</code> waits for all standard error lines from
a process. It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentially several <code>readLines()</code> calls.
It returns a character vector. This will return content only if
<code>stderr="|"</code> was used. Otherwise, it will throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_all_error_lines()</pre></div>


<hr>
<a id="method-process-write_input"></a>



<h4>Method <code>write_input()</code></h4>

<p><code style="white-space: pre;">$write_input()</code> writes the character vector (separated by <code>sep</code>) to
the standard input of the process. It will be converted to the specified
encoding. This operation is non-blocking, and it will return, even if
the write fails (because the write buffer is full), or if it suceeds
partially (i.e. not the full string is written). It returns with a raw
vector, that contains the bytes that were not written. You can supply
this raw vector to <code style="white-space: pre;">$write_input()</code> again, until it is fully written,
and then the return value will be <code>raw(0)</code> (invisibly).
</p>


<h5>Usage</h5>

<div class="r"><pre>process$write_input(str, sep = "\n")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>str</code></dt><dd><p>Character or raw vector to write to the standard input
of the process. If a character vector with a marked encoding,
it will be converted to <code>encoding</code>.</p>
</dd>
<dt><code>sep</code></dt><dd><p>Separator to add between <code>str</code> elements if it is a
character vector. It is ignored if <code>str</code> is a raw vector.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Leftover text (as a raw vector), that was not written.
</p>


<hr>
<a id="method-process-get_input_file"></a>



<h4>Method <code>get_input_file()</code></h4>

<p><code style="white-space: pre;">$get_input_file()</code> if the <code>stdin</code> argument was a filename,
this returns the absolute path to the file. If <code>stdin</code> was <code>"|"</code> or
<code>NULL</code>, this simply returns that value.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_input_file()</pre></div>


<hr>
<a id="method-process-get_output_file"></a>



<h4>Method <code>get_output_file()</code></h4>

<p><code style="white-space: pre;">$get_output_file()</code> if the <code>stdout</code> argument was a filename,
this returns the absolute path to the file. If <code>stdout</code> was <code>"|"</code> or
<code>NULL</code>, this simply returns that value.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_output_file()</pre></div>


<hr>
<a id="method-process-get_error_file"></a>



<h4>Method <code>get_error_file()</code></h4>

<p><code style="white-space: pre;">$get_error_file()</code> if the <code>stderr</code> argument was a filename,
this returns the absolute path to the file. If <code>stderr</code> was <code>"|"</code> or
<code>NULL</code>, this simply returns that value.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_error_file()</pre></div>


<hr>
<a id="method-process-poll_io"></a>



<h4>Method <code>poll_io()</code></h4>

<p><code style="white-space: pre;">$poll_io()</code> polls the process's connections for I/O. See more in
the <em>Polling</em> section, and see also the <code><a href="poll.html">poll()</a></code> function
to poll on multiple processes.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$poll_io(timeout)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>timeout</code></dt><dd><p>Timeout in milliseconds, for the wait or the I/O
polling.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-get_poll_connection"></a>



<h4>Method <code>get_poll_connection()</code></h4>

<p><code style="white-space: pre;">$get_poll_connetion()</code> returns the poll connection, if the process has
one.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_poll_connection()</pre></div>


<hr>
<a id="method-process-get_result"></a>



<h4>Method <code>get_result()</code></h4>

<p><code style="white-space: pre;">$get_result()</code> returns the result of the post processesing function.
It can only be called once the process has finished. If the process has
no post-processing function, then <code>NULL</code> is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_result()</pre></div>


<hr>
<a id="method-process-as_ps_handle"></a>



<h4>Method <code>as_ps_handle()</code></h4>

<p><code style="white-space: pre;">$as_ps_handle()</code> returns a <a href="../../ps/html/ps_handle.html">ps::ps_handle</a> object, corresponding to
the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$as_ps_handle()</pre></div>


<hr>
<a id="method-process-get_name"></a>



<h4>Method <code>get_name()</code></h4>

<p>Calls <code><a href="../../ps/html/ps_name.html">ps::ps_name()</a></code> to get the process name.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_name()</pre></div>


<hr>
<a id="method-process-get_exe"></a>



<h4>Method <code>get_exe()</code></h4>

<p>Calls <code><a href="../../ps/html/ps_exe.html">ps::ps_exe()</a></code> to get the path of the executable.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_exe()</pre></div>


<hr>
<a id="method-process-get_cmdline"></a>



<h4>Method <code>get_cmdline()</code></h4>

<p>Calls <code><a href="../../ps/html/ps_cmdline.html">ps::ps_cmdline()</a></code> to get the command line.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_cmdline()</pre></div>


<hr>
<a id="method-process-get_status"></a>



<h4>Method <code>get_status()</code></h4>

<p>Calls <code><a href="../../ps/html/ps_status.html">ps::ps_status()</a></code> to get the process status.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_status()</pre></div>


<hr>
<a id="method-process-get_username"></a>



<h4>Method <code>get_username()</code></h4>

<p>calls <code><a href="../../ps/html/ps_username.html">ps::ps_username()</a></code> to get the username.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_username()</pre></div>


<hr>
<a id="method-process-get_wd"></a>



<h4>Method <code>get_wd()</code></h4>

<p>Calls <code><a href="../../ps/html/ps_cwd.html">ps::ps_cwd()</a></code> to get the current working directory.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_wd()</pre></div>


<hr>
<a id="method-process-get_cpu_times"></a>



<h4>Method <code>get_cpu_times()</code></h4>

<p>Calls <code><a href="../../ps/html/ps_cpu_times.html">ps::ps_cpu_times()</a></code> to get CPU usage data.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_cpu_times()</pre></div>


<hr>
<a id="method-process-get_memory_info"></a>



<h4>Method <code>get_memory_info()</code></h4>

<p>Calls <code><a href="../../ps/html/ps_memory_info.html">ps::ps_memory_info()</a></code> to get memory data.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_memory_info()</pre></div>


<hr>
<a id="method-process-suspend"></a>



<h4>Method <code>suspend()</code></h4>

<p>Calls <code><a href="../../ps/html/ps_suspend.html">ps::ps_suspend()</a></code> to suspend the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$suspend()</pre></div>


<hr>
<a id="method-process-resume"></a>



<h4>Method <code>resume()</code></h4>

<p>Calls <code><a href="../../ps/html/ps_resume.html">ps::ps_resume()</a></code> to resume a suspended process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$resume()</pre></div>




<h3>Examples</h3>

<pre>

p &lt;- process$new("sleep", "2")
p$is_alive()
p
p$kill()
p$is_alive()

p &lt;- process$new("sleep", "1")
p$is_alive()
Sys.sleep(2)
p$is_alive()

</pre>

<hr /><div style="text-align: center;">[Package <em>processx</em> version 3.7.0 <a href="00Index.html">Index</a>]</div>
</body></html>
