<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Firth's Bias-Reduced Logistic Regression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for logistf {logistf}"><tr><td>logistf {logistf}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Firth's Bias-Reduced Logistic Regression
</h2>

<h3>Description</h3>

<p>Implements Firth's bias-Reduced penalized-likelihood logistic regression.
</p>


<h3>Usage</h3>

<pre>
logistf(formula = attr(data, "formula"), data = sys.parent(), pl = TRUE, 
   alpha = 0.05, control, plcontrol, firth = TRUE, init, weights, 
   plconf = NULL, dataout = TRUE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>

<p>a formula object, with the response on the left of the  operator, and the
model terms on the right. The response must be a vector with 0 and 1 or FALSE and
TRUE for the  outcome, where the higher value (1 or TRUE) is modeled. It is possible
to include contrasts, interactions, nested effects, cubic or polynomial splines and all
S features as well, e.g. <code>Y ~ X1*X2 + ns(X3, df=4)</code>. From version 1.10, you may also include
offset() terms.
</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>

<p>a data.frame where the variables named in the formula can be found, i. e.
the variables containing the binary response and the covariates.
</p>
</td></tr>
<tr valign="top"><td><code>pl</code></td>
<td>

<p>specifies if confidence intervals and tests should be based on the profile penalized
log likelihood (<code>pl=TRUE</code>, the default) or on the Wald method (<code>pl=FALSE</code>).
</p>
</td></tr>
<tr valign="top"><td><code>alpha</code></td>
<td>

<p>the significance level (1-<i>&alpha;</i> the confidence level,
0.05 as default).</p>
</td></tr>
<tr valign="top"><td><code>control</code></td>
<td>

<p>Controls Newton-Raphson iteration. Default is <code>control=</code> <code>logistf.control(maxstep,</code>
<code>maxit, maxhs, lconv, gconv, xconv</code>)
</p>
</td></tr>
<tr valign="top"><td><code>plcontrol</code></td>
<td>

<p>Controls Newton-Raphson iteration for the estimation of the profile likelihood confidence intervals.
Default is <code>plcontrol=</code> <code>logistpl.control(maxstep,</code> 
<code>maxit,</code>  <code>maxhs, lconv, xconv, ortho, pr</code>)
</p>
</td></tr>
<tr valign="top"><td><code>firth</code></td>
<td>

<p>use of Firth's penalized maximum likelihood (<code>firth=TRUE</code>, default) or the
standard maximum likelihood method (<code>firth=FALSE</code>) for the logistic regression. Note
that by specifying <code>pl=TRUE</code> and <code>firth=FALSE</code> (and probably a lower number of iterations)
one obtains profile likelihood confidence intervals for maximum likelihood logistic
regression parameters.
</p>
</td></tr>
<tr valign="top"><td><code>init</code></td>
<td>

<p>specifies the initial values of the coefficients for the fitting algorithm.
</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>

<p>specifies case weights. Each line of the input data set is multiplied by the corresponding element of <code>weights</code>.
</p>
</td></tr>
<tr valign="top"><td><code>plconf</code></td>
<td>

<p>specifies the variables (as vector of their indices) for which profile likelihood confidence intervals should
be computed. Default is to compute for all variables.
</p>
</td></tr>
<tr valign="top"><td><code>dataout</code></td>
<td>

<p>If TRUE, copies the <code>data</code> set to the output object.
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>Further arguments to be passed to logistf.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>logistf</code> is the main function of the package. It fits a logistic regression model applying Firth's correction to the likelihood. 
The following generic methods are available for <code>logistf</code>'s output
object: <code>print</code>, <code>summary</code>, <code>coef</code>, <code>vcov</code>, <code>confint</code>, <code>anova</code>, <code>extractAIC</code>, <code>add1</code>, <code>drop1</code>, <code>profile</code>, <code>terms</code>, <code>nobs</code>.
Furthermore, <code>forward</code> and <code>backward</code> functions perform convenient variable selection. Note that <code>anova</code>, <code>extractAIC</code>,  <code>add1</code>, <code>drop1</code>,   <code>forward</code> and <code>backward</code> 
are based on penalized likelihood ratios.
</p>


<h3>Value</h3>

<p>The object returned is of the class logistf and has the following attributes:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>coefficients</code></td>
<td>
<p> the coefficients of the parameter in the fitted model.</p>
</td></tr>
<tr valign="top"><td><code>alpha</code></td>
<td>
<p> the significance level (1- the confidence level) as specified in the input.</p>
</td></tr>
<tr valign="top"><td><code>terms</code></td>
<td>
<p>the column names of the design matrix</p>
</td></tr>
<tr valign="top"><td><code>var</code></td>
<td>
<p> the variance-covariance-matrix of the parameters.</p>
</td></tr>
<tr valign="top"><td><code>df</code></td>
<td>
<p> the number of degrees of freedom in the model.</p>
</td></tr>
<tr valign="top"><td><code>loglik</code></td>
<td>
<p> a vector of the (penalized) log-likelihood of the full and the restricted models.</p>
</td></tr>
<tr valign="top"><td><code>iter</code></td>
<td>
<p> the number of iterations needed in the fitting process.</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p> the number of observations.</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p> the response-vector, i. e. 1 for successes (events) and 0 for failures.</p>
</td></tr>
<tr valign="top"><td><code>formula</code></td>
<td>
<p> the formula object.</p>
</td></tr>
<tr valign="top"><td><code>call</code></td>
<td>
<p> the call object.</p>
</td></tr>
<tr valign="top"><td><code>terms</code></td>
<td>
<p>the model terms (column names of design matrix).</p>
</td></tr>
<tr valign="top"><td><code>linear.predictors</code></td>
<td>
<p> a vector with the linear predictor of each observation.</p>
</td></tr>
<tr valign="top"><td><code>predict</code></td>
<td>
<p> a vector with the predicted probability of each observation.</p>
</td></tr>
<tr valign="top"><td><code>hat.diag</code></td>
<td>
<p> a vector with the diagonal elements of the Hat Matrix.</p>
</td></tr>
<tr valign="top"><td><code>conv</code></td>
<td>
<p>the convergence status at last iteration: a vector of length 3 with elements: last change in log likelihood, max(abs(score vector)), max change in beta at last iteration.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p> depending on the fitting method &lsquo;Penalized ML&rsquo; or &lsquo;Standard ML&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>method.ci</code></td>
<td>
<p> the method in calculating the confidence intervals, i.e. &lsquo;profile likelihood&rsquo; or &lsquo;Wald&rsquo;, depending on the argument pl.</p>
</td></tr>
<tr valign="top"><td><code>ci.lower</code></td>
<td>
<p> the lower confidence limits of the parameter.</p>
</td></tr>
<tr valign="top"><td><code>ci.upper</code></td>
<td>
<p> the upper confidence limits of the parameter.</p>
</td></tr>
<tr valign="top"><td><code>prob</code></td>
<td>
<p> the p-values of the specific parameters.</p>
</td></tr>
<tr valign="top"><td><code>pl.iter</code></td>
<td>
<p>only if pl==TRUE: the number of iterations needed for each confidence limit.</p>
</td></tr>
<tr valign="top"><td><code>betahist</code></td>
<td>
<p>only if pl==TRUE: the complete history of beta estimates for each confidence limit.</p>
</td></tr>
<tr valign="top"><td><code>pl.conv</code></td>
<td>
<p>only if pl==TRUE: the convergence status (deviation of log likelihood from target value, last maximum change in beta)
for each confidence limit.</p>
</td></tr>
</table>
<p>If <code>dataout=TRUE</code>, additionally:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>data</code></td>
<td>
<p>a copy of the input data set</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>the weights variable (if applicable)</p>
</td></tr>                 
</table>


<h3>Author(s)</h3>

<p>Georg Heinze and Meinhard Ploner
</p>


<h3>References</h3>

<p>Firth D (1993). Bias reduction of maximum likelihood estimates. <em>Biometrika</em> 
80, 27&ndash;38.
</p>
<p>Heinze G, Schemper M (2002). A solution to the problem of 
separation in logistic regression. <em>Statistics in Medicine</em> 21: 2409-2419.
</p>
<p>Heinze G, Ploner M (2003). Fixing the nonconvergence bug in 
logistic regression with SPLUS and SAS. <em>Computer Methods and 
Programs in Biomedicine</em> 71: 181-187.
</p>
<p>Heinze G, Ploner M (2004). Technical Report 2/2004: A SAS-macro, S-PLUS library and
R package to perform logistic regression without convergence problems.
Section of Clinical Biometrics, Department of
Medical Computer Sciences, Medical University of Vienna, Vienna, Austria.
<a href="http://www.meduniwien.ac.at/user/georg.heinze/techreps/tr2_2004.pdf">http://www.meduniwien.ac.at/user/georg.heinze/techreps/tr2_2004.pdf</a>
</p>
<p>Heinze G (2006). A comparative investigation of methods for logistic regression
with separated or nearly separated data. <em>Statistics in Medicine</em> 25: 4216-4226.
</p>
<p>Venzon DJ, Moolgavkar AH (1988). A method for computing profile-likelihood
based confidence intervals. <em>Applied Statistics</em> 37:87-94.
</p>


<h3>See Also</h3>

<p><code><a href="../../logistf/help/drop1.logistf.html">drop1.logistf</a></code>
<code><a href="../../logistf/help/add1.logistf.html">add1.logistf</a></code>
<code><a href="../../logistf/help/anova.logistf.html">anova.logistf</a></code>
</p>


<h3>Examples</h3>

<pre>
data(sex2)
fit&lt;-logistf(case ~ age+oc+vic+vicl+vis+dia, data=sex2)
summary(fit)
nobs(fit)
drop1(fit)
plot(profile(fit,variable="dia"))

extractAIC(fit)

fit1&lt;-update(fit, case ~ age+oc+vic+vicl+vis)
extractAIC(fit1)
anova(fit,fit1)


data(sexagg)
fit2&lt;-logistf(case ~ age+oc+vic+vicl+vis+dia, data=sexagg, weights=COUNT)
summary(fit2)


# simulated SNP example
# not run
set.seed(72341)
snpdata&lt;-rbind(
    matrix(rbinom(2000,2,runif(2000)*0.3),100,20),
    matrix(rbinom(2000,2,runif(2000)*0.5),100,20))
colnames(snpdata)&lt;-paste("SNP",1:20,"_",sep="")
snpdata&lt;-as.data.frame(snpdata)
for(i in 1:20) snpdata[,i]&lt;-as.factor(snpdata[,i])
snpdata$case&lt;-c(rep(0,100),rep(1,100))


fitsnp&lt;-logistf(data=snpdata, formula=case~1, pl=FALSE)
add1(fitsnp)
fitf&lt;-forward(fitsnp)
fitf

</pre>

<hr /><div style="text-align: center;">[Package <em>logistf</em> version 1.22 <a href="00Index.html">Index</a>]</div>
</div></body></html>
