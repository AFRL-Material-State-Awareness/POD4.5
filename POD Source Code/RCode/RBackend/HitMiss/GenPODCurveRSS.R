#     Probability of Detection Version 4.5 (PODv4.5)
#     Copyright (C) 2022  University of Dayton Research Institute (UDRI)
# 
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <https://www.gnu.org/licenses/>.

###Genertaes points for the POD curve and returns the result as a dataframe
#NOTE: the increment and step size plots 198 points total. It is designed to capture the critical A values to save time in the calculation
#the default constructor for c(0,0,0) is simply to fill the simCrackSizes metric

# parameters:
# logitResultsPOD =  a list of the logistic regression result objects (firth or maximum likelihood). This should
# be of size 30 by default (maxresamples is typically set to 30)
# excludeNA = boolean flag to determine if NA values are excluded when taking the median (should always be set to true)
# RSSDataFrmaes = a list of the ranked set sample dataframes generated (should also be 30 like logitResultsList)
# simCrackSizes = an array of the simulated crack sizes (normally distributed)
# origDataSet = the original dataframe the user entered in POD
# pODCurveDF = the dataframe holding the POD curve and confidence interval (flaw, POD, confidence_interval). It's values are generated by taking
# the median of the 30 resamples
# covarMatrix = the variance-covariance matrix median values based on the 30 reamples
# goodnessOfFit = the median of the goodness of fit values based on the 30 resamples
# t_transDataFrameMed = array of medians of the t_trans values (POD)
# probsAt95CIDataFrameMed = array of medians of the values at 95% confidence (Confidence_Interval)

GenPODCurveRSS<-setRefClass("GenPODCurveRSS", fields = list(logitResultsPOD="list", excludeNA="logical",RSSDataFrames="list",
                            simCrackSizes="numeric",origDataSet= "data.frame", pODCurveDF="data.frame", covarMatrix="matrix", goodnessOfFit="numeric", t_transDataFrameMed=
                              "data.frame", probsAt95CIDataFrameMed= "data.frame"),
                            methods = list(
                              initialize=function(logitResultsPODInput=list(),excludeNAInput=TRUE,RSSDataFramesInput=list() ,
                                                  simCrackSizesInput=c(0,0,0),origDataSetInput=data.frame(matrix(ncol = 1, nrow = 0))){
                                logitResultsPOD<<-logitResultsPODInput
                                excludeNA<<-excludeNAInput
                                RSSDataFrames<<-RSSDataFramesInput
                                simCrackSizes<<-simCrackSizesInput
                                origDataSet<<-origDataSetInput
                              },
                              getPODCurveDF=function(){
                                return(pODCurveDF)
                              },
                              setPODCurveDF=function(pspODCurveDF){
                                pODCurveDF<<-pspODCurveDF
                              },
                              getMedianCovarMatrix=function(){
                                return(covarMatrix)
                              },
                              setMedianCovarMatrix=function(psCovarMatrix){
                                covarMatrix<<-psCovarMatrix
                              },
                              setGoodnessOfFit=function(psGoodFit){
                                goodnessOfFit<<-psGoodFit
                              },
                              getGoodnessOfFit=function(){
                                return(goodnessOfFit)
                              },
                              newWaldGen=function(){
                                t_transDataFrameMed<<-data.frame("Index"=1:length(nrow(origDataSet)))
                                probsAt95CIDataFrameMed<<-data.frame("Index"=1:length(nrow(origDataSet)))
                                #store all of the values for the covariance matrices
                                covar11=c()
                                covar12=c()
                                covar21=c()
                                covar22=c()
                                #used to store the goodness of fit values
                                goodnessOfFitValues=c()
                                for(i in 1:length(logitResultsPOD)){
                                  linear_pred=predict(logitResultsPOD[[i]], type="link", se.fit=TRUE,
                                                      newdata=data.frame(x=origDataSet$x))
                                  #generate the variance-covariance matrix
                                  varcovmat =vcov(logitResultsPOD[[i]])
                                  #varCovarMatrixList=append(varCovarMatrixList, list(varcovmat))
                                  covar11=append(covar11, varcovmat[1,1])
                                  covar12=append(covar12, varcovmat[1,2])
                                  covar21=append(covar21, varcovmat[2,1])
                                  covar22=append(covar22, varcovmat[2,2])
                                  thisGoodnessOfFit=logitResultsPOD[[i]]$deviance/logitResultsPOD[[i]]$null.deviance
                                  goodnessOfFitValues=append(goodnessOfFitValues, thisGoodnessOfFit)
                                  sigmaOfCrack_i = sqrt(varcovmat[1,1]+2*varcovmat[1,2]*
                                                          logitResultsPOD[[i]]$data$x+varcovmat[2,2]*
                                                          logitResultsPOD[[i]]$data$x^2)
                                  currProbs = logitResultsPOD[[i]]$family$linkinv(linear_pred$fit)
                                  currProbsAt95CI = logitResultsPOD[[i]]$family$linkinv(linear_pred$fit-qnorm(0.95)*sigmaOfCrack_i)
                                  #print(length(probsAt95CI))
                                  t_transDataFrameMed<<-cbind(t_transDataFrameMed, currProbs)
                                  probsAt95CIDataFrameMed<<-cbind(probsAt95CIDataFrameMed, currProbsAt95CI)
                                }
                                setGoodnessOfFit(median(goodnessOfFitValues))
                                medianCovarMatrix=matrix(nrow=2, ncol=2)
                                medianCovarMatrix[1,1]=median(covar11)
                                medianCovarMatrix[1,2]=median(covar12)
                                medianCovarMatrix[2,1]=median(covar21)
                                medianCovarMatrix[2,2]=median(covar22)
                                setMedianCovarMatrix(medianCovarMatrix)
                                #create the POD and confint columns by taking the medians
                                t_transDataFrameMed$Index<<-NULL
                                probsAt95CIDataFrameMed$Index<<-NULL
                                #calculate medians and store them in final DF column 
                                t_trans=c()
                                Confidence_Interval=c()
                                #loop through the t_trans=POd and confident interval dataframe rows to generate the POD and CI curve
                                for(i in 1:nrow(origDataSet)){
                                  t_trans=c(t_trans, median(as.numeric(t_transDataFrameMed[i,]), na.rm = TRUE))
                                  Confidence_Interval=c(Confidence_Interval, 
                                                        median(as.numeric(probsAt95CIDataFrameMed[i,]), na.rm = TRUE))
                                }
                                PODCurve=data.frame(
                                  "x"=origDataSet$x,
                                  "transformFlaw"=rep(0,length(origDataSet$x)),
                                  "t_trans"= t_trans,
                                  "Confidence_Interval"=Confidence_Interval
                                )
                                setPODCurveDF(PODCurve)
                              },
                              genPODModWald=function(){
                                #Get the median values for the goodness of fit and varcovar matrix
                                genGoodFitAndMatrixSimCracks()
                                t_transDataFrameMed$Index<<-NULL
                                probsAt95CIDataFrameMed$Index<<-NULL
                                #calculate medians and store them in final DF column 
                                t_trans=c()
                                Confidence_Interval=c()
                                for(i in 1:length(simCrackSizes)){
                                  t_trans=c(t_trans, median(as.numeric(t_transDataFrameMed[i,]), na.rm = TRUE))
                                  Confidence_Interval=c(Confidence_Interval, 
                                                        median(as.numeric(probsAt95CIDataFrameMed[i,]), na.rm = TRUE))
                                }
                                PODCurve=data.frame(
                                  "x"=simCrackSizes,
                                  "transformFlaw"=rep(0,length(simCrackSizes)),
                                  "t_trans"= t_trans,
                                  "Confidence_Interval"=Confidence_Interval
                                )
                                setPODCurveDF(PODCurve)
                              },
                              genPODLR=function(){
                                #Get the median values for the goodness of fit and varcovar matrix
                                genGoodFitAndMatrixSimCracks()
                                print("starting LR RSS")
                                #generate the Lr conf interval with RSS(WARNING: VERY SLOW)
                                #Initialize the K matrix
                                a=simCrackSizes
                                a_i_2 = sort(a)[seq(from=1,to=length(a),length.out=length(simCrackSizes))]
                                K = matrix(c(rep(1,length(a_i_2)),a_i_2),ncol=2)
                                finalConfInt=list()
                                print("no parallel")
                                for(i in 1:length(logitResultsPOD)){
                                  print("step 1")
                                  calcLinearCombo=unclass(genLinearCombosRSS(logitResultsPOD[[i]], K))
                                  print("step 2")
                                  newLRConfInt=LikelihoodRatioConfInt$new(LogisticRegressionResult=logitResultsPOD[[i]])
                                  print("step 3")
                                  newLRConfInt$setLinCombo(unclass(calcLinearCombo))
                                  print("step 4")
                                  newLRConfInt$executeLR()
                                  print("step 5")
                                  finalConfInt=append(finalConfInt, data.frame(newLRConfInt$getCIDataFrame()))
                                }
                                #finalConfIntGlobal<<-finalConfInt
                                t_transList=list()
                                confIntList=list()
                                for(i in 1:length(finalConfInt)){
                                  if(i%%2==1){
                                    t_transList=append(t_transList, finalConfInt[i])
                                  }
                                  else if (i%%2==0){
                                    confIntList=append(confIntList, finalConfInt[i])
                                  }
                                }
                                t_transDF=data.frame(t_transList)
                                confIntListDF=data.frame(confIntList)
                                #calculate medians and store them in final DF column 
                                t_trans=c()
                                Confidence_Interval=c()
                                for(i in 1:length(as.numeric(simCrackSizes))){
                                  t_trans=append(t_trans, median(as.numeric(t_transDF[i,]), na.rm = TRUE))
                                  Confidence_Interval=append(Confidence_Interval,
                                                       median(as.numeric(confIntListDF[i,]), na.rm = TRUE))
                                }
                                print("FINISHED!")
                                PODCurve=data.frame(
                                  "x"=simCrackSizes,
                                  "transformFlaw"=rep(0, length(simCrackSizes)),
                                  "t_trans"= t_trans,
                                  "Confidence_Interval"=Confidence_Interval
                                )
                                #globalPODCurve<<-PODCurve
                                setPODCurveDF(PODCurve)
                                
                              },
                              genPODMLR=function(){
                                #Get the median values for the goodness of fit and varcovar matrix
                                genGoodFitAndMatrixSimCracks()
                                print("starting MLR RSS")
                                options(warn=-1)
                                #generate the MLr conf interval with RSS(WARNING: VERY SLOW)
                                #Initialize the K matrix
                                a=simCrackSizes
                                a_i_2 = sort(a)[seq(from=1,to=length(a),length.out=length(simCrackSizes))]
                                K = matrix(c(rep(1,length(a_i_2)),a_i_2),ncol=2)
                                finalConfInt=list()
                                print("no parallel")
                                for(i in 1:length(logitResultsPOD)){
                                  calcLinearCombo=unclass(genLinearCombosRSS(logitResultsPOD[[i]], K))
                                  newMLRConfInt=ModifiedLikelihoodRatioConfInt$new(LogisticRegressionResult=logitResultsPOD[[i]])
                                  newMLRConfInt$setLinCombo(unclass(calcLinearCombo))
                                  newMLRConfInt$executeMLR()
                                  finalConfInt=append(finalConfInt, data.frame(newMLRConfInt$getCIDataFrame()))
                                }
                                #finalConfIntGlobal<<-finalConfInt
                                t_transList=list()
                                confIntList=list()
                                for(i in 1:length(finalConfInt)){
                                  if(i%%2==1){
                                    t_transList=append(t_transList, finalConfInt[i])
                                  }
                                  else if (i%%2==0){
                                    confIntList=append(confIntList, finalConfInt[i])
                                  }
                                }
                                t_transDF=data.frame(t_transList)
                                confIntListDF=data.frame(confIntList)
                                #calculate medians and store them in final DF column 
                                t_trans=c()
                                Confidence_Interval=c()
                                for(i in 1:length(as.numeric(simCrackSizes))){
                                  t_trans=append(t_trans, median(as.numeric(t_transDF[i,]), na.rm = TRUE))
                                  Confidence_Interval=append(Confidence_Interval,
                                                             median(as.numeric(confIntListDF[i,]), na.rm = TRUE))
                                }
                                print("FINISHED!")
                                PODCurve=data.frame(
                                  "x"=simCrackSizes,
                                  "transformFlaw"=rep(0,length(simCrackSizes)),
                                  "t_trans"= t_trans,
                                  "Confidence_Interval"=Confidence_Interval
                                )
                                setPODCurveDF(PODCurve)
                                
                              },
                              #In addition to getting the goodness of fit and varcovar matrix,
                              #this function also gets the t_trans and confint values from each logit (only used in Modified wald)
                              #split up this function for better readability
                              genGoodFitAndMatrixSimCracks=function(){
                                #store all of the values for the covariance matrices
                                covar11=c()
                                covar12=c()
                                covar21=c()
                                covar22=c()
                                #used to store the goodness of fit values
                                goodnessOfFitValues=c()
                                t_transDataFrameMed<<-data.frame("Index"=1:length(simCrackSizes))
                                probsAt95CIDataFrameMed<<-data.frame("Index"=1:length(simCrackSizes))
                                for(i in 1:length(logitResultsPOD)){
                                  linear_pred=predict(logitResultsPOD[[i]], type="link", se.fit=TRUE, 
                                                      newdata=data.frame(x=simCrackSizes))
                                  varcovmat =vcov(logitResultsPOD[[i]])
                                  covar11=append(covar11, varcovmat[1,1])
                                  covar12=append(covar12, varcovmat[1,2])
                                  covar21=append(covar21, varcovmat[2,1])
                                  covar22=append(covar22, varcovmat[2,2])
                                  thisGoodnessOfFit=logitResultsPOD[[i]]$deviance/logitResultsPOD[[i]]$null.deviance
                                  goodnessOfFitValues=append(goodnessOfFitValues, thisGoodnessOfFit)
                                  sigmaOfCrack_i = sqrt(varcovmat[1,1]+2*varcovmat[1,2]*
                                                          simCrackSizes+varcovmat[2,2]*
                                                          simCrackSizes^2)
                                  currt_trans = logitResultsPOD[[i]]$family$linkinv(linear_pred$fit)
                                  currProbsAt95CI = logitResultsPOD[[i]]$family$linkinv(linear_pred$fit-qnorm(0.95)*sigmaOfCrack_i)
                                  
                                  t_transDataFrameMed<<-cbind(t_transDataFrameMed, currt_trans)
                                  probsAt95CIDataFrameMed<<-cbind(probsAt95CIDataFrameMed, currProbsAt95CI)
                                }
                                setGoodnessOfFit(median(goodnessOfFitValues))
                                #globalVarCovar<<-varCovarMatrixList
                                medianCovarMatrix=matrix(nrow=2, ncol=2)
                                medianCovarMatrix[1,1]=median(covar11)
                                medianCovarMatrix[1,2]=median(covar12)
                                medianCovarMatrix[2,1]=median(covar21)
                                medianCovarMatrix[2,2]=median(covar22)
                                #globalcovar<<-medianCovarMatrix
                                setMedianCovarMatrix(medianCovarMatrix)
                              },
                              genLinearCombosRSS=function(LogisticRegressionResult, KMatrix){
                                print("combo time!")
                                ptm <- proc.time()
                                linearCombo<-mcprofile(object = LogisticRegressionResult, CM = KMatrix)# Calculate -2log(Lambda)
                                #linearCombo<-minimcprofile(object = LogisticRegressionResult, CM = KMatrix)# Calculate -2log(Lambda)
                                print("combo done!")
                                print(proc.time() - ptm)
                                return(linearCombo)
                              }
                          ))
